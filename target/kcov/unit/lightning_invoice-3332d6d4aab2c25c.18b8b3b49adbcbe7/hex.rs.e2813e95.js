var data = {lines:[
{"lineNum":"    1","line":"// Bitcoin Hashes Library"},
{"lineNum":"    2","line":"// Written in 2018 by"},
{"lineNum":"    3","line":"//   Andrew Poelstra <apoelstra@wpsoftware.net>"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// To the extent possible under law, the author(s) have dedicated all"},
{"lineNum":"    6","line":"// copyright and related and neighboring rights to this software to"},
{"lineNum":"    7","line":"// the public domain worldwide. This software is distributed without"},
{"lineNum":"    8","line":"// any warranty."},
{"lineNum":"    9","line":"//"},
{"lineNum":"   10","line":"// You should have received a copy of the CC0 Public Domain Dedication"},
{"lineNum":"   11","line":"// along with this software."},
{"lineNum":"   12","line":"// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>."},
{"lineNum":"   13","line":"//"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"//! # Hex encoding and decoding"},
{"lineNum":"   16","line":"//!"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"use core::{fmt, str};"},
{"lineNum":"   19","line":"use Hash;"},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"/// Hex decoding error"},
{"lineNum":"   22","line":"#[derive(Debug, Copy, Clone, PartialEq, Eq)]","class":"lineNoCov","hits":"0","possible_hits":"9",},
{"lineNum":"   23","line":"pub enum Error {"},
{"lineNum":"   24","line":"    /// non-hexadecimal character"},
{"lineNum":"   25","line":"    InvalidChar(u8),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   26","line":"    /// purported hex string had odd length"},
{"lineNum":"   27","line":"    OddLengthString(usize),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   28","line":"    /// tried to parse fixed-length hash from a string with the wrong type (expected, got)"},
{"lineNum":"   29","line":"    InvalidLength(usize, usize),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   30","line":"}"},
{"lineNum":"   31","line":""},
{"lineNum":"   32","line":"impl fmt::Display for Error {"},
{"lineNum":"   33","line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"   34","line":"        match *self {"},
{"lineNum":"   35","line":"            Error::InvalidChar(ch) => write!(f, \"invalid hex character {}\", ch),"},
{"lineNum":"   36","line":"            Error::OddLengthString(ell) => write!(f, \"odd hex string length {}\", ell),"},
{"lineNum":"   37","line":"            Error::InvalidLength(ell, ell2) => write!(f, \"bad hex string length {} (expected {})\", ell2, ell),"},
{"lineNum":"   38","line":"        }"},
{"lineNum":"   39","line":"    }"},
{"lineNum":"   40","line":"}"},
{"lineNum":"   41","line":""},
{"lineNum":"   42","line":"/// Trait for objects that can be serialized as hex strings"},
{"lineNum":"   43","line":"#[cfg(any(test, feature = \"std\"))]"},
{"lineNum":"   44","line":"pub trait ToHex {"},
{"lineNum":"   45","line":"    /// Hex representation of the object"},
{"lineNum":"   46","line":"    fn to_hex(&self) -> String;"},
{"lineNum":"   47","line":"}"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"/// Trait for objects that can be deserialized from hex strings"},
{"lineNum":"   50","line":"pub trait FromHex: Sized {"},
{"lineNum":"   51","line":"    /// Produce an object from a byte iterator"},
{"lineNum":"   52","line":"    fn from_byte_iter<I>(iter: I) -> Result<Self, Error>"},
{"lineNum":"   53","line":"        where I: Iterator<Item=Result<u8, Error>> +"},
{"lineNum":"   54","line":"            ExactSizeIterator +"},
{"lineNum":"   55","line":"            DoubleEndedIterator;"},
{"lineNum":"   56","line":""},
{"lineNum":"   57","line":"    /// Produce an object from a hex string"},
{"lineNum":"   58","line":"    fn from_hex(s: &str) -> Result<Self, Error> {","class":"lineCov","hits":"1","order":"2807","possible_hits":"1",},
{"lineNum":"   59","line":"        Self::from_byte_iter(HexIterator::new(s)?)","class":"linePartCov","hits":"1","order":"2808","possible_hits":"2",},
{"lineNum":"   60","line":"    }","class":"linePartCov","hits":"2","order":"2965","possible_hits":"3",},
{"lineNum":"   61","line":"}"},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"#[cfg(any(test, feature = \"std\"))]"},
{"lineNum":"   64","line":"impl<T: fmt::LowerHex> ToHex for T {"},
{"lineNum":"   65","line":"    /// Outputs the hash in hexadecimal form"},
{"lineNum":"   66","line":"    fn to_hex(&self) -> String {"},
{"lineNum":"   67","line":"        format!(\"{:x}\", self)"},
{"lineNum":"   68","line":"    }"},
{"lineNum":"   69","line":"}"},
{"lineNum":"   70","line":""},
{"lineNum":"   71","line":"impl<T: Hash> FromHex for T {"},
{"lineNum":"   72","line":"    fn from_byte_iter<I>(iter: I) -> Result<Self, Error>","class":"linePartCov","hits":"1","order":"2828","possible_hits":"2",},
{"lineNum":"   73","line":"        where I: Iterator<Item=Result<u8, Error>> +"},
{"lineNum":"   74","line":"            ExactSizeIterator +"},
{"lineNum":"   75","line":"            DoubleEndedIterator,"},
{"lineNum":"   76","line":"    {"},
{"lineNum":"   77","line":"        let inner;","class":"lineCov","hits":"1","order":"2829","possible_hits":"1",},
{"lineNum":"   78","line":"        if Self::DISPLAY_BACKWARD {","class":"linePartCov","hits":"2","order":"2831","possible_hits":"3",},
{"lineNum":"   79","line":"            inner = T::Inner::from_byte_iter(iter.rev())?;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"   80","line":"        } else {"},
{"lineNum":"   81","line":"            inner = T::Inner::from_byte_iter(iter)?;","class":"linePartCov","hits":"2","order":"2833","possible_hits":"3",},
{"lineNum":"   82","line":"        }"},
{"lineNum":"   83","line":"        Ok(Hash::from_inner(inner))","class":"lineCov","hits":"1","order":"2959","possible_hits":"1",},
{"lineNum":"   84","line":"    }","class":"linePartCov","hits":"2","order":"2963","possible_hits":"3",},
{"lineNum":"   85","line":"}"},
{"lineNum":"   86","line":""},
{"lineNum":"   87","line":"/// Iterator over a hex-encoded string slice which decodes hex and yields bytes."},
{"lineNum":"   88","line":"pub struct HexIterator<\'a> {"},
{"lineNum":"   89","line":"    /// The `Bytes` iterator whose next two bytes will be decoded to yield"},
{"lineNum":"   90","line":"    /// the next byte."},
{"lineNum":"   91","line":"    iter: str::Bytes<\'a>,"},
{"lineNum":"   92","line":"}"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"impl<\'a> HexIterator<\'a> {"},
{"lineNum":"   95","line":"    /// Constructs a new `HexIterator` from a string slice. If the string is of"},
{"lineNum":"   96","line":"    /// odd length it returns an error."},
{"lineNum":"   97","line":"    pub fn new(s: &\'a str) -> Result<HexIterator<\'a>, Error> {","class":"lineCov","hits":"1","order":"2810","possible_hits":"1",},
{"lineNum":"   98","line":"        if s.len() % 2 != 0 {","class":"linePartCov","hits":"1","order":"2811","possible_hits":"2",},
{"lineNum":"   99","line":"            Err(Error::OddLengthString(s.len()))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  100","line":"        } else {"},
{"lineNum":"  101","line":"            Ok(HexIterator { iter: s.bytes() })","class":"lineCov","hits":"2","order":"2815","possible_hits":"2",},
{"lineNum":"  102","line":"        }"},
{"lineNum":"  103","line":"    }","class":"linePartCov","hits":"1","order":"2825","possible_hits":"2",},
{"lineNum":"  104","line":"}"},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"fn chars_to_hex(hi: u8, lo: u8) -> Result<u8, Error> {","class":"lineCov","hits":"1","order":"2913","possible_hits":"1",},
{"lineNum":"  107","line":"    let hih = (hi as char)","class":"linePartCov","hits":"3","order":"2914","possible_hits":"4",},
{"lineNum":"  108","line":"        .to_digit(16)"},
{"lineNum":"  109","line":"        .ok_or(Error::InvalidChar(hi))?;","class":"linePartCov","hits":"2","order":"2922","possible_hits":"4",},
{"lineNum":"  110","line":"    let loh = (lo as char)","class":"linePartCov","hits":"3","order":"2926","possible_hits":"4",},
{"lineNum":"  111","line":"        .to_digit(16)"},
{"lineNum":"  112","line":"        .ok_or(Error::InvalidChar(lo))?;","class":"linePartCov","hits":"2","order":"2927","possible_hits":"3",},
{"lineNum":"  113","line":""},
{"lineNum":"  114","line":"    let ret = (hih << 4) + loh;","class":"linePartCov","hits":"2","order":"2932","possible_hits":"4",},
{"lineNum":"  115","line":"    Ok(ret as u8)","class":"lineCov","hits":"1","order":"2933","possible_hits":"1",},
{"lineNum":"  116","line":"}","class":"lineCov","hits":"2","order":"2934","possible_hits":"2",},
{"lineNum":"  117","line":""},
{"lineNum":"  118","line":"impl<\'a> Iterator for HexIterator<\'a> {"},
{"lineNum":"  119","line":"    type Item = Result<u8, Error>;"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"    fn next(&mut self) -> Option<Result<u8, Error>> {","class":"lineCov","hits":"1","order":"2876","possible_hits":"1",},
{"lineNum":"  122","line":"        let hi = self.iter.next()?;","class":"linePartCov","hits":"2","order":"2877","possible_hits":"3",},
{"lineNum":"  123","line":"        let lo = self.iter.next().unwrap();","class":"lineCov","hits":"2","order":"2903","possible_hits":"2",},
{"lineNum":"  124","line":"        Some(chars_to_hex(hi, lo))","class":"lineCov","hits":"1","order":"2912","possible_hits":"1",},
{"lineNum":"  125","line":"    }","class":"linePartCov","hits":"2","order":"2937","possible_hits":"3",},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    fn size_hint(&self) -> (usize, Option<usize>) {","class":"lineCov","hits":"1","order":"2837","possible_hits":"1",},
{"lineNum":"  128","line":"        let (min, max) = self.iter.size_hint();","class":"lineCov","hits":"1","order":"2838","possible_hits":"1",},
{"lineNum":"  129","line":"        (min / 2, max.map(|x| x /2))","class":"lineCov","hits":"3","order":"2846","possible_hits":"3",},
{"lineNum":"  130","line":"    }","class":"linePartCov","hits":"1","order":"2849","possible_hits":"2",},
{"lineNum":"  131","line":"}"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"impl<\'a> DoubleEndedIterator for HexIterator<\'a> {"},
{"lineNum":"  134","line":"    fn next_back(&mut self) -> Option<Result<u8, Error>> {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  135","line":"        let lo = self.iter.next_back()?;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  136","line":"        let hi = self.iter.next_back().unwrap();","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  137","line":"        Some(chars_to_hex(hi, lo))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  138","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  139","line":"}"},
{"lineNum":"  140","line":""},
{"lineNum":"  141","line":"impl<\'a> ExactSizeIterator for HexIterator<\'a> {}"},
{"lineNum":"  142","line":""},
{"lineNum":"  143","line":"/// Output hex into an object implementing `fmt::Write`, which is usually more"},
{"lineNum":"  144","line":"/// efficient than going through a `String` using `ToHex`."},
{"lineNum":"  145","line":"pub fn format_hex(data: &[u8], f: &mut fmt::Formatter) -> fmt::Result {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  146","line":"    let prec = f.precision().unwrap_or(2 * data.len());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  147","line":"    let width = f.width().unwrap_or(2 * data.len());","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  148","line":"    for _ in (2 * data.len())..width {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  149","line":"        f.write_str(\"0\")?;","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  150","line":"    }"},
{"lineNum":"  151","line":"    for ch in data.iter().take(prec / 2) {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  152","line":"        write!(f, \"{:02x}\", *ch)?;","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  153","line":"    }"},
{"lineNum":"  154","line":"    if prec < 2 * data.len() && prec % 2 == 1 {","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  155","line":"        write!(f, \"{:x}\", data[prec / 2] / 16)?;","class":"lineNoCov","hits":"0","possible_hits":"4",},
{"lineNum":"  156","line":"    }"},
{"lineNum":"  157","line":"    Ok(())","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  158","line":"}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"/// Output hex in reverse order; used for Sha256dHash whose standard hex encoding"},
{"lineNum":"  161","line":"/// has the bytes reversed."},
{"lineNum":"  162","line":"pub fn format_hex_reverse(data: &[u8], f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  163","line":"    let prec = f.precision().unwrap_or(2 * data.len());"},
{"lineNum":"  164","line":"    let width = f.width().unwrap_or(2 * data.len());"},
{"lineNum":"  165","line":"    for _ in (2 * data.len())..width {"},
{"lineNum":"  166","line":"        f.write_str(\"0\")?;"},
{"lineNum":"  167","line":"    }"},
{"lineNum":"  168","line":"    for ch in data.iter().rev().take(prec / 2) {"},
{"lineNum":"  169","line":"        write!(f, \"{:02x}\", *ch)?;"},
{"lineNum":"  170","line":"    }"},
{"lineNum":"  171","line":"    if prec < 2 * data.len() && prec % 2 == 1 {"},
{"lineNum":"  172","line":"        write!(f, \"{:x}\", data[data.len() - 1 - prec / 2] / 16)?;"},
{"lineNum":"  173","line":"    }"},
{"lineNum":"  174","line":"    Ok(())"},
{"lineNum":"  175","line":"}"},
{"lineNum":"  176","line":""},
{"lineNum":"  177","line":"#[cfg(any(test, feature = \"std\"))]"},
{"lineNum":"  178","line":"impl ToHex for [u8] {"},
{"lineNum":"  179","line":"    fn to_hex(&self) -> String {"},
{"lineNum":"  180","line":"        use core::fmt::Write;"},
{"lineNum":"  181","line":"        let mut ret = String::with_capacity(2 * self.len());"},
{"lineNum":"  182","line":"        for ch in self {"},
{"lineNum":"  183","line":"            write!(ret, \"{:02x}\", ch).expect(\"writing to string\");"},
{"lineNum":"  184","line":"        }"},
{"lineNum":"  185","line":"        ret"},
{"lineNum":"  186","line":"    }"},
{"lineNum":"  187","line":"}"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"#[cfg(any(test, feature = \"std\"))]"},
{"lineNum":"  190","line":"impl FromHex for Vec<u8> {"},
{"lineNum":"  191","line":"    fn from_byte_iter<I>(iter: I) -> Result<Self, Error>"},
{"lineNum":"  192","line":"        where I: Iterator<Item=Result<u8, Error>> +"},
{"lineNum":"  193","line":"            ExactSizeIterator +"},
{"lineNum":"  194","line":"            DoubleEndedIterator,"},
{"lineNum":"  195","line":"    {"},
{"lineNum":"  196","line":"        iter.collect()"},
{"lineNum":"  197","line":"    }"},
{"lineNum":"  198","line":"}"},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"macro_rules! impl_fromhex_array {"},
{"lineNum":"  201","line":"    ($len:expr) => {"},
{"lineNum":"  202","line":"        impl FromHex for [u8; $len] {"},
{"lineNum":"  203","line":"            fn from_byte_iter<I>(iter: I) -> Result<Self, Error>","class":"linePartCov","hits":"1","order":"2835","possible_hits":"4",},
{"lineNum":"  204","line":"                where I: Iterator<Item=Result<u8, Error>> +"},
{"lineNum":"  205","line":"                    ExactSizeIterator +"},
{"lineNum":"  206","line":"                    DoubleEndedIterator,"},
{"lineNum":"  207","line":"            {"},
{"lineNum":"  208","line":"                if iter.len() == $len {","class":"linePartCov","hits":"3","order":"2836","possible_hits":"6",},
{"lineNum":"  209","line":"                    let mut ret = [0; $len];","class":"linePartCov","hits":"1","order":"2856","possible_hits":"2",},
{"lineNum":"  210","line":"                    for (n, byte) in iter.enumerate() {","class":"linePartCov","hits":"3","order":"2857","possible_hits":"8",},
{"lineNum":"  211","line":"                        ret[n] = byte?;","class":"linePartCov","hits":"2","order":"2949","possible_hits":"8",},
{"lineNum":"  212","line":"                    }","class":"linePartCov","hits":"1","order":"2956","possible_hits":"6",},
{"lineNum":"  213","line":"                    Ok(ret)","class":"linePartCov","hits":"1","order":"2957","possible_hits":"2",},
{"lineNum":"  214","line":"                } else {"},
{"lineNum":"  215","line":"                    Err(Error::InvalidLength(2 * $len, 2 * iter.len()))","class":"lineNoCov","hits":"0","possible_hits":"8",},
{"lineNum":"  216","line":"                }"},
{"lineNum":"  217","line":"            }","class":"linePartCov","hits":"2","order":"2958","possible_hits":"6",},
{"lineNum":"  218","line":"        }"},
{"lineNum":"  219","line":"    }"},
{"lineNum":"  220","line":"}"},
{"lineNum":"  221","line":""},
{"lineNum":"  222","line":"impl_fromhex_array!(2);"},
{"lineNum":"  223","line":"impl_fromhex_array!(4);"},
{"lineNum":"  224","line":"impl_fromhex_array!(6);"},
{"lineNum":"  225","line":"impl_fromhex_array!(8);"},
{"lineNum":"  226","line":"impl_fromhex_array!(10);"},
{"lineNum":"  227","line":"impl_fromhex_array!(12);"},
{"lineNum":"  228","line":"impl_fromhex_array!(14);"},
{"lineNum":"  229","line":"impl_fromhex_array!(16);"},
{"lineNum":"  230","line":"impl_fromhex_array!(20);"},
{"lineNum":"  231","line":"impl_fromhex_array!(24);"},
{"lineNum":"  232","line":"impl_fromhex_array!(28);"},
{"lineNum":"  233","line":"impl_fromhex_array!(32);"},
{"lineNum":"  234","line":"impl_fromhex_array!(33);"},
{"lineNum":"  235","line":"impl_fromhex_array!(64);"},
{"lineNum":"  236","line":"impl_fromhex_array!(65);"},
{"lineNum":"  237","line":"impl_fromhex_array!(128);"},
{"lineNum":"  238","line":"impl_fromhex_array!(256);"},
{"lineNum":"  239","line":"impl_fromhex_array!(384);"},
{"lineNum":"  240","line":"impl_fromhex_array!(512);"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"#[cfg(test)]"},
{"lineNum":"  243","line":"mod tests {"},
{"lineNum":"  244","line":"    use super::*;"},
{"lineNum":"  245","line":""},
{"lineNum":"  246","line":"    use core::fmt;"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"    #[test]"},
{"lineNum":"  249","line":"    fn hex_roundtrip() {"},
{"lineNum":"  250","line":"        let expected = \"0123456789abcdef\";"},
{"lineNum":"  251","line":"        let expected_up = \"0123456789ABCDEF\";"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"        let parse: Vec<u8> = FromHex::from_hex(expected).expect(\"parse lowercase string\");"},
{"lineNum":"  254","line":"        assert_eq!(parse, vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);"},
{"lineNum":"  255","line":"        let ser = parse.to_hex();"},
{"lineNum":"  256","line":"        assert_eq!(ser, expected);"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"        let parse: Vec<u8> = FromHex::from_hex(expected_up).expect(\"parse uppercase string\");"},
{"lineNum":"  259","line":"        assert_eq!(parse, vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);"},
{"lineNum":"  260","line":"        let ser = parse.to_hex();"},
{"lineNum":"  261","line":"        assert_eq!(ser, expected);"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"        let parse: [u8; 8] = FromHex::from_hex(expected_up).expect(\"parse uppercase string\");"},
{"lineNum":"  264","line":"        assert_eq!(parse, [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);"},
{"lineNum":"  265","line":"        let ser = parse.to_hex();"},
{"lineNum":"  266","line":"        assert_eq!(ser, expected);"},
{"lineNum":"  267","line":"    }"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"    #[test]"},
{"lineNum":"  270","line":"    fn hex_truncate() {"},
{"lineNum":"  271","line":"        struct HexBytes(Vec<u8>);"},
{"lineNum":"  272","line":"        impl fmt::LowerHex for HexBytes {"},
{"lineNum":"  273","line":"            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  274","line":"                format_hex(&self.0, f)"},
{"lineNum":"  275","line":"            }"},
{"lineNum":"  276","line":"        }"},
{"lineNum":"  277","line":""},
{"lineNum":"  278","line":"        let bytes = HexBytes(vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"        assert_eq!("},
{"lineNum":"  281","line":"            format!(\"{:x}\", bytes),"},
{"lineNum":"  282","line":"            \"0102030405060708090a\""},
{"lineNum":"  283","line":"        );"},
{"lineNum":"  284","line":""},
{"lineNum":"  285","line":"        for i in 0..20 {"},
{"lineNum":"  286","line":"            assert_eq!("},
{"lineNum":"  287","line":"                format!(\"{:.prec$x}\", bytes, prec = i),"},
{"lineNum":"  288","line":"                &\"0102030405060708090a\"[0..i]"},
{"lineNum":"  289","line":"            );"},
{"lineNum":"  290","line":"        }"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"        assert_eq!("},
{"lineNum":"  293","line":"            format!(\"{:25x}\", bytes),"},
{"lineNum":"  294","line":"            \"000000102030405060708090a\""},
{"lineNum":"  295","line":"        );"},
{"lineNum":"  296","line":"        assert_eq!("},
{"lineNum":"  297","line":"            format!(\"{:26x}\", bytes),"},
{"lineNum":"  298","line":"            \"0000000102030405060708090a\""},
{"lineNum":"  299","line":"        );"},
{"lineNum":"  300","line":"    }"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"    #[test]"},
{"lineNum":"  303","line":"    fn hex_truncate_rev() {"},
{"lineNum":"  304","line":"        struct HexBytes(Vec<u8>);"},
{"lineNum":"  305","line":"        impl fmt::LowerHex for HexBytes {"},
{"lineNum":"  306","line":"            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  307","line":"                format_hex_reverse(&self.0, f)"},
{"lineNum":"  308","line":"            }"},
{"lineNum":"  309","line":"        }"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"        let bytes = HexBytes(vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10]);"},
{"lineNum":"  312","line":""},
{"lineNum":"  313","line":"        assert_eq!("},
{"lineNum":"  314","line":"            format!(\"{:x}\", bytes),"},
{"lineNum":"  315","line":"            \"0a090807060504030201\""},
{"lineNum":"  316","line":"        );"},
{"lineNum":"  317","line":""},
{"lineNum":"  318","line":"        for i in 0..20 {"},
{"lineNum":"  319","line":"            assert_eq!("},
{"lineNum":"  320","line":"                format!(\"{:.prec$x}\", bytes, prec = i),"},
{"lineNum":"  321","line":"                &\"0a090807060504030201\"[0..i]"},
{"lineNum":"  322","line":"            );"},
{"lineNum":"  323","line":"        }"},
{"lineNum":"  324","line":""},
{"lineNum":"  325","line":"        assert_eq!("},
{"lineNum":"  326","line":"            format!(\"{:25x}\", bytes),"},
{"lineNum":"  327","line":"            \"000000a090807060504030201\""},
{"lineNum":"  328","line":"        );"},
{"lineNum":"  329","line":"        assert_eq!("},
{"lineNum":"  330","line":"            format!(\"{:26x}\", bytes),"},
{"lineNum":"  331","line":"            \"0000000a090807060504030201\""},
{"lineNum":"  332","line":"        );"},
{"lineNum":"  333","line":"    }"},
{"lineNum":"  334","line":""},
{"lineNum":"  335","line":"    #[test]"},
{"lineNum":"  336","line":"    fn hex_error() {"},
{"lineNum":"  337","line":"        let oddlen = \"0123456789abcdef0\";"},
{"lineNum":"  338","line":"        let badchar1 = \"Z123456789abcdef\";"},
{"lineNum":"  339","line":"        let badchar2 = \"012Y456789abcdeb\";"},
{"lineNum":"  340","line":"        let badchar3 = \"«23456789abcdef\";"},
{"lineNum":"  341","line":""},
{"lineNum":"  342","line":"        assert_eq!("},
{"lineNum":"  343","line":"            Vec::<u8>::from_hex(oddlen),"},
{"lineNum":"  344","line":"            Err(Error::OddLengthString(17))"},
{"lineNum":"  345","line":"        );"},
{"lineNum":"  346","line":"        assert_eq!("},
{"lineNum":"  347","line":"            <[u8; 4]>::from_hex(oddlen),"},
{"lineNum":"  348","line":"            Err(Error::OddLengthString(17))"},
{"lineNum":"  349","line":"        );"},
{"lineNum":"  350","line":"        assert_eq!("},
{"lineNum":"  351","line":"            <[u8; 8]>::from_hex(oddlen),"},
{"lineNum":"  352","line":"            Err(Error::OddLengthString(17))"},
{"lineNum":"  353","line":"        );"},
{"lineNum":"  354","line":"        assert_eq!("},
{"lineNum":"  355","line":"            Vec::<u8>::from_hex(badchar1),"},
{"lineNum":"  356","line":"            Err(Error::InvalidChar(b\'Z\'))"},
{"lineNum":"  357","line":"        );"},
{"lineNum":"  358","line":"        assert_eq!("},
{"lineNum":"  359","line":"            Vec::<u8>::from_hex(badchar2),"},
{"lineNum":"  360","line":"            Err(Error::InvalidChar(b\'Y\'))"},
{"lineNum":"  361","line":"        );"},
{"lineNum":"  362","line":"        assert_eq!("},
{"lineNum":"  363","line":"            Vec::<u8>::from_hex(badchar3),"},
{"lineNum":"  364","line":"            Err(Error::InvalidChar(194))"},
{"lineNum":"  365","line":"        );"},
{"lineNum":"  366","line":"    }"},
{"lineNum":"  367","line":"}"},
{"lineNum":"  368","line":""},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "lightning_invoice-3332d6d4aab2c25c", "date" : "2020-05-23 13:12:48", "instrumented" : 61, "covered" : 38,};
var merged_data = [];
