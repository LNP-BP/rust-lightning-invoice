var data = {lines:[
{"lineNum":"    1","line":"// Copyright (c) 2017 Clark Moody"},
{"lineNum":"    2","line":"//"},
{"lineNum":"    3","line":"// Permission is hereby granted, free of charge, to any person obtaining a copy"},
{"lineNum":"    4","line":"// of this software and associated documentation files (the \"Software\"), to deal"},
{"lineNum":"    5","line":"// in the Software without restriction, including without limitation the rights"},
{"lineNum":"    6","line":"// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell"},
{"lineNum":"    7","line":"// copies of the Software, and to permit persons to whom the Software is"},
{"lineNum":"    8","line":"// furnished to do so, subject to the following conditions:"},
{"lineNum":"    9","line":"//"},
{"lineNum":"   10","line":"// The above copyright notice and this permission notice shall be included in"},
{"lineNum":"   11","line":"// all copies or substantial portions of the Software."},
{"lineNum":"   12","line":"//"},
{"lineNum":"   13","line":"// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR"},
{"lineNum":"   14","line":"// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,"},
{"lineNum":"   15","line":"// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE"},
{"lineNum":"   16","line":"// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER"},
{"lineNum":"   17","line":"// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,"},
{"lineNum":"   18","line":"// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN"},
{"lineNum":"   19","line":"// THE SOFTWARE."},
{"lineNum":"   20","line":""},
{"lineNum":"   21","line":"//! Encoding and decoding Bech32 format"},
{"lineNum":"   22","line":"//!"},
{"lineNum":"   23","line":"//! Bech32 is a 5-bit (base-32) encoding scheme that produces strings that comprise"},
{"lineNum":"   24","line":"//! a human-readable part, a separator, a data part, and a checksum. The encoding"},
{"lineNum":"   25","line":"//! implements a BCH code that guarantees error detection of up to four characters"},
{"lineNum":"   26","line":"//! with less than 1 in 1 billion chance of failing to detect more errors."},
{"lineNum":"   27","line":"//!"},
{"lineNum":"   28","line":"//! The Bech32 encoding was originally formulated in [BIP-0173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)"},
{"lineNum":"   29","line":"//!"},
{"lineNum":"   30","line":"//! # Examples"},
{"lineNum":"   31","line":"//!"},
{"lineNum":"   32","line":"//! ```rust"},
{"lineNum":"   33","line":"//! use bech32::{self, FromBase32, ToBase32};"},
{"lineNum":"   34","line":"//!"},
{"lineNum":"   35","line":"//! let encoded = bech32::encode(\"bech32\", vec![0x00, 0x01, 0x02].to_base32()).unwrap();"},
{"lineNum":"   36","line":"//! assert_eq!(encoded, \"bech321qqqsyrhqy2a\".to_string());"},
{"lineNum":"   37","line":"//!"},
{"lineNum":"   38","line":"//! let (hrp, data) = bech32::decode(&encoded).unwrap();"},
{"lineNum":"   39","line":"//! assert_eq!(hrp, \"bech32\");"},
{"lineNum":"   40","line":"//! assert_eq!(Vec::<u8>::from_base32(&data).unwrap(), vec![0x00, 0x01, 0x02]);"},
{"lineNum":"   41","line":"//! ```"},
{"lineNum":"   42","line":"//!"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"// Allow trait objects without dyn on nightly and make 1.22 ignore the unknown lint"},
{"lineNum":"   45","line":"#![allow(unknown_lints)]"},
{"lineNum":"   46","line":"#![allow(bare_trait_objects)]"},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#![deny(missing_docs)]"},
{"lineNum":"   49","line":"#![deny(non_upper_case_globals)]"},
{"lineNum":"   50","line":"#![deny(non_camel_case_types)]"},
{"lineNum":"   51","line":"#![deny(non_snake_case)]"},
{"lineNum":"   52","line":"#![deny(unused_mut)]"},
{"lineNum":"   53","line":"#![cfg_attr(feature = \"strict\", deny(warnings))]"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"use std::{error, fmt};"},
{"lineNum":"   56","line":"use std::borrow::Cow;"},
{"lineNum":"   57","line":""},
{"lineNum":"   58","line":"// AsciiExt is needed for Rust 1.14 but not for newer versions"},
{"lineNum":"   59","line":"#[allow(unused_imports, deprecated)]"},
{"lineNum":"   60","line":"use std::ascii::AsciiExt;"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"/// Integer in the range `0..32`"},
{"lineNum":"   63","line":"#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, PartialOrd, Ord, Hash)]","class":"linePartCov","hits":"6","order":"2239","possible_hits":"10",},
{"lineNum":"   64","line":"#[allow(non_camel_case_types)]"},
{"lineNum":"   65","line":"pub struct u5(u8);","class":"linePartCov","hits":"2","order":"2359","possible_hits":"4",},
{"lineNum":"   66","line":""},
{"lineNum":"   67","line":"impl u5 {"},
{"lineNum":"   68","line":"    /// Convert a `u8` to `u5` if in range, return `Error` otherwise"},
{"lineNum":"   69","line":"    pub fn try_from_u8(value: u8) -> Result<u5, Error> {","class":"lineCov","hits":"1","order":"1874","possible_hits":"1",},
{"lineNum":"   70","line":"        if value > 31 {","class":"lineCov","hits":"2","order":"1875","possible_hits":"2",},
{"lineNum":"   71","line":"            Err(Error::InvalidData(value))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"   72","line":"        } else {"},
{"lineNum":"   73","line":"            Ok(u5(value))","class":"lineCov","hits":"1","order":"1876","possible_hits":"1",},
{"lineNum":"   74","line":"        }"},
{"lineNum":"   75","line":"    }","class":"linePartCov","hits":"1","order":"1877","possible_hits":"2",},
{"lineNum":"   76","line":""},
{"lineNum":"   77","line":"    /// Returns a copy of the underlying `u8` value"},
{"lineNum":"   78","line":"    pub fn to_u8(&self) -> u8 {","class":"lineCov","hits":"1","order":"2332","possible_hits":"1",},
{"lineNum":"   79","line":"        self.0","class":"lineCov","hits":"1","order":"2333","possible_hits":"1",},
{"lineNum":"   80","line":"    }","class":"linePartCov","hits":"1","order":"2334","possible_hits":"2",},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"    /// Get char representing this 5 bit value as defined in BIP173"},
{"lineNum":"   83","line":"    pub fn to_char(&self) -> char {"},
{"lineNum":"   84","line":"        CHARSET[self.to_u8() as usize]"},
{"lineNum":"   85","line":"    }"},
{"lineNum":"   86","line":"}"},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"impl Into<u8> for u5 {"},
{"lineNum":"   89","line":"    fn into(self) -> u8 {","class":"lineCov","hits":"1","order":"2019","possible_hits":"1",},
{"lineNum":"   90","line":"        self.0"},
{"lineNum":"   91","line":"    }","class":"linePartCov","hits":"1","order":"2020","possible_hits":"2",},
{"lineNum":"   92","line":"}"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"impl AsRef<u8> for u5 {"},
{"lineNum":"   95","line":"    fn as_ref(&self) -> &u8 {","class":"lineCov","hits":"1","order":"3319","possible_hits":"1",},
{"lineNum":"   96","line":"        &self.0"},
{"lineNum":"   97","line":"    }","class":"linePartCov","hits":"1","order":"3320","possible_hits":"2",},
{"lineNum":"   98","line":"}"},
{"lineNum":"   99","line":""},
{"lineNum":"  100","line":"/// Interface to write `u5`s into a sink"},
{"lineNum":"  101","line":"pub trait WriteBase32 {"},
{"lineNum":"  102","line":"    /// Write error"},
{"lineNum":"  103","line":"    type Err: fmt::Debug;"},
{"lineNum":"  104","line":""},
{"lineNum":"  105","line":"    /// Write a `u5` slice"},
{"lineNum":"  106","line":"    fn write(&mut self, data: &[u5]) -> Result<(), Self::Err> {"},
{"lineNum":"  107","line":"        for b in data {"},
{"lineNum":"  108","line":"            self.write_u5(*b)?;"},
{"lineNum":"  109","line":"        }"},
{"lineNum":"  110","line":"        Ok(())"},
{"lineNum":"  111","line":"    }"},
{"lineNum":"  112","line":""},
{"lineNum":"  113","line":"    /// Write a single `u5`"},
{"lineNum":"  114","line":"    fn write_u5(&mut self, data: u5) -> Result<(), Self::Err>;"},
{"lineNum":"  115","line":"}"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"/// Allocationless Bech32 writer that accumulates the checksum data internally and writes them out"},
{"lineNum":"  118","line":"/// in the end."},
{"lineNum":"  119","line":"pub struct Bech32Writer<\'a> {"},
{"lineNum":"  120","line":"    formatter: &\'a mut fmt::Write,"},
{"lineNum":"  121","line":"    chk: u32,"},
{"lineNum":"  122","line":"}"},
{"lineNum":"  123","line":""},
{"lineNum":"  124","line":"impl<\'a> Bech32Writer<\'a> {"},
{"lineNum":"  125","line":"    /// Creates a new writer that can write a bech32 string without allocating itself."},
{"lineNum":"  126","line":"    ///"},
{"lineNum":"  127","line":"    /// This is a rather low-level API and doesn\'t check the HRP or data length for standard"},
{"lineNum":"  128","line":"    /// compliance."},
{"lineNum":"  129","line":"    pub fn new(hrp: &str, fmt: &\'a mut fmt::Write) -> Result<Bech32Writer<\'a>, fmt::Error> {"},
{"lineNum":"  130","line":"        let mut writer = Bech32Writer {"},
{"lineNum":"  131","line":"            formatter: fmt,"},
{"lineNum":"  132","line":"            chk: 1,"},
{"lineNum":"  133","line":"        };"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"        writer.formatter.write_str(hrp)?;"},
{"lineNum":"  136","line":"        writer.formatter.write_char(SEP)?;"},
{"lineNum":"  137","line":""},
{"lineNum":"  138","line":"        // expand HRP"},
{"lineNum":"  139","line":"        for b in hrp.bytes() {"},
{"lineNum":"  140","line":"            writer.polymod_step(u5(b >> 5));"},
{"lineNum":"  141","line":"        }"},
{"lineNum":"  142","line":"        writer.polymod_step(u5(0));"},
{"lineNum":"  143","line":"        for b in hrp.bytes() {"},
{"lineNum":"  144","line":"            writer.polymod_step(u5(b & 0x1f));"},
{"lineNum":"  145","line":"        }"},
{"lineNum":"  146","line":""},
{"lineNum":"  147","line":"        Ok(writer)"},
{"lineNum":"  148","line":"    }"},
{"lineNum":"  149","line":""},
{"lineNum":"  150","line":"    fn polymod_step(&mut self, v: u5) {"},
{"lineNum":"  151","line":"        let b = (self.chk >> 25) as u8;"},
{"lineNum":"  152","line":"        self.chk = (self.chk & 0x1ffffff) << 5 ^ (u32::from(*v.as_ref()));"},
{"lineNum":"  153","line":"        for i in 0..5 {"},
{"lineNum":"  154","line":"            if (b >> i) & 1 == 1 {"},
{"lineNum":"  155","line":"                self.chk ^= GEN[i]"},
{"lineNum":"  156","line":"            }"},
{"lineNum":"  157","line":"        }"},
{"lineNum":"  158","line":"    }"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"    /// Write out the checksum at the end. If this method isn\'t called this will happen on drop."},
{"lineNum":"  161","line":"    pub fn finalize(mut self) -> fmt::Result {"},
{"lineNum":"  162","line":"        self.inner_finalize()?;"},
{"lineNum":"  163","line":"        std::mem::forget(self);"},
{"lineNum":"  164","line":"        Ok(())"},
{"lineNum":"  165","line":"    }"},
{"lineNum":"  166","line":""},
{"lineNum":"  167","line":"    fn inner_finalize(&mut self) -> fmt::Result {"},
{"lineNum":"  168","line":"        // Pad with 6 zeros"},
{"lineNum":"  169","line":"        for _ in 0..6 {"},
{"lineNum":"  170","line":"            self.polymod_step(u5(0))"},
{"lineNum":"  171","line":"        }"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"        let plm: u32 = self.chk ^ 1;"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"        for p in 0..6 {"},
{"lineNum":"  176","line":"            self.formatter.write_char("},
{"lineNum":"  177","line":"                u5(((plm >> (5 * (5 - p))) & 0x1f) as u8).to_char()"},
{"lineNum":"  178","line":"            )?;"},
{"lineNum":"  179","line":"        }"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"        Ok(())"},
{"lineNum":"  182","line":"    }"},
{"lineNum":"  183","line":"}"},
{"lineNum":"  184","line":"impl<\'a> WriteBase32 for Bech32Writer<\'a> {"},
{"lineNum":"  185","line":"    type Err = fmt::Error;"},
{"lineNum":"  186","line":""},
{"lineNum":"  187","line":"    /// Writes a single 5 bit value of the data part"},
{"lineNum":"  188","line":"    fn write_u5(&mut self, data: u5) -> fmt::Result {"},
{"lineNum":"  189","line":"        self.polymod_step(data);"},
{"lineNum":"  190","line":"        self.formatter.write_char(data.to_char())"},
{"lineNum":"  191","line":"    }"},
{"lineNum":"  192","line":"}"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"impl<\'a> Drop for Bech32Writer<\'a> {"},
{"lineNum":"  195","line":"    fn drop(&mut self) {"},
{"lineNum":"  196","line":"        self.inner_finalize().expect(\"Unhandled error writing the checksum on drop.\")"},
{"lineNum":"  197","line":"    }"},
{"lineNum":"  198","line":"}"},
{"lineNum":"  199","line":""},
{"lineNum":"  200","line":"/// Parse/convert base32 slice to `Self`. It is the reciprocal of"},
{"lineNum":"  201","line":"/// `ToBase32`."},
{"lineNum":"  202","line":"pub trait FromBase32: Sized {"},
{"lineNum":"  203","line":"    /// The associated error which can be returned from parsing (e.g. because of bad padding)."},
{"lineNum":"  204","line":"    type Err;"},
{"lineNum":"  205","line":""},
{"lineNum":"  206","line":"    /// Convert a base32 slice to `Self`."},
{"lineNum":"  207","line":"    fn from_base32(b32: &[u5]) -> Result<Self, Self::Err>;"},
{"lineNum":"  208","line":"}"},
{"lineNum":"  209","line":""},
{"lineNum":"  210","line":"impl WriteBase32 for Vec<u5> {"},
{"lineNum":"  211","line":"    type Err = ();"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"    fn write(&mut self, data: &[u5]) -> Result<(), Self::Err> {","class":"lineCov","hits":"1","order":"4136","possible_hits":"1",},
{"lineNum":"  214","line":"        self.extend_from_slice(data);","class":"lineCov","hits":"1","order":"4137","possible_hits":"1",},
{"lineNum":"  215","line":"        Ok(())"},
{"lineNum":"  216","line":"    }","class":"linePartCov","hits":"1","order":"4138","possible_hits":"2",},
{"lineNum":"  217","line":""},
{"lineNum":"  218","line":"    fn write_u5(&mut self, data: u5) -> Result<(), Self::Err> {","class":"lineCov","hits":"1","order":"4163","possible_hits":"1",},
{"lineNum":"  219","line":"        self.push(data);","class":"lineCov","hits":"1","order":"4164","possible_hits":"1",},
{"lineNum":"  220","line":"        Ok(())"},
{"lineNum":"  221","line":"    }","class":"linePartCov","hits":"1","order":"4165","possible_hits":"2",},
{"lineNum":"  222","line":"}"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"impl FromBase32 for Vec<u8> {"},
{"lineNum":"  225","line":"    type Err = Error;"},
{"lineNum":"  226","line":""},
{"lineNum":"  227","line":"    /// Convert base32 to base256, removes null-padding if present, returns"},
{"lineNum":"  228","line":"    /// `Err(Error::InvalidPadding)` if padding bits are unequal `0`"},
{"lineNum":"  229","line":"    fn from_base32(b32: &[u5]) -> Result<Self, Self::Err> {","class":"lineCov","hits":"1","order":"2006","possible_hits":"1",},
{"lineNum":"  230","line":"        convert_bits(b32, 5, 8, false)","class":"lineCov","hits":"1","order":"2007","possible_hits":"1",},
{"lineNum":"  231","line":"    }","class":"linePartCov","hits":"1","order":"2075","possible_hits":"2",},
{"lineNum":"  232","line":"}"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"/// A trait for converting a value to a type `T` that represents a `u5` slice."},
{"lineNum":"  235","line":"pub trait ToBase32 {"},
{"lineNum":"  236","line":"    /// Convert `Self` to base32 vector"},
{"lineNum":"  237","line":"    fn to_base32(&self) -> Vec<u5> {","class":"linePartCov","hits":"1","order":"4120","possible_hits":"2",},
{"lineNum":"  238","line":"        let mut vec = Vec::new();","class":"lineCov","hits":"1","order":"4121","possible_hits":"1",},
{"lineNum":"  239","line":"        self.write_base32(&mut vec).unwrap();","class":"lineCov","hits":"1","order":"4122","possible_hits":"1",},
{"lineNum":"  240","line":"        vec","class":"lineCov","hits":"1","order":"4226","possible_hits":"1",},
{"lineNum":"  241","line":"    }","class":"linePartCov","hits":"1","order":"4227","possible_hits":"2",},
{"lineNum":"  242","line":""},
{"lineNum":"  243","line":"    /// Encode as base32 and write it to the supplied writer"},
{"lineNum":"  244","line":"    /// Implementations shouldn\'t allocate."},
{"lineNum":"  245","line":"    fn write_base32<W: WriteBase32>(&self, writer: &mut W) -> Result<(), <W as WriteBase32>::Err>;"},
{"lineNum":"  246","line":"}"},
{"lineNum":"  247","line":""},
{"lineNum":"  248","line":"/// Interface to calculate the length of the base32 representation before actually serializing"},
{"lineNum":"  249","line":"pub trait Base32Len: ToBase32 {"},
{"lineNum":"  250","line":"    /// Calculate the base32 serialized length"},
{"lineNum":"  251","line":"    fn base32_len(&self) -> usize;"},
{"lineNum":"  252","line":"}"},
{"lineNum":"  253","line":""},
{"lineNum":"  254","line":"impl<T: AsRef<[u8]>> ToBase32 for T {"},
{"lineNum":"  255","line":"    fn write_base32<W: WriteBase32>(&self, writer: &mut W) -> Result<(), <W as WriteBase32>::Err> {","class":"linePartCov","hits":"1","order":"4172","possible_hits":"4",},
{"lineNum":"  256","line":"        // Amount of bits left over from last round, stored in buffer."},
{"lineNum":"  257","line":"        let mut buffer_bits = 0u32;","class":"linePartCov","hits":"1","order":"4173","possible_hits":"2",},
{"lineNum":"  258","line":"        // Holds all unwritten bits left over from last round. The bits are stored beginning from"},
{"lineNum":"  259","line":"        // the most significant bit. E.g. if buffer_bits=3, then the byte with bits a, b and c will"},
{"lineNum":"  260","line":"        // look as follows: [a, b, c, 0, 0, 0, 0, 0]"},
{"lineNum":"  261","line":"        let mut buffer: u8 = 0;","class":"linePartCov","hits":"1","order":"4174","possible_hits":"2",},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"        for &b in self.as_ref() {","class":"linePartCov","hits":"3","order":"4175","possible_hits":"8",},
{"lineNum":"  264","line":"            // Write first u5 if we have to write two u5s this round. That only happens if the"},
{"lineNum":"  265","line":"            // buffer holds too many bits, so we don\'t have to combine buffer bits with new bits"},
{"lineNum":"  266","line":"            // from this rounds byte."},
{"lineNum":"  267","line":"            if buffer_bits >= 5 {","class":"linePartCov","hits":"1","order":"4176","possible_hits":"2",},
{"lineNum":"  268","line":"                writer.write_u5(u5((buffer & 0b11111000) >> 3))?;","class":"linePartCov","hits":"1","order":"4182","possible_hits":"4",},
{"lineNum":"  269","line":"                buffer = buffer << 5;","class":"linePartCov","hits":"1","order":"4183","possible_hits":"2",},
{"lineNum":"  270","line":"                buffer_bits -= 5;","class":"linePartCov","hits":"1","order":"4184","possible_hits":"4",},
{"lineNum":"  271","line":"            }"},
{"lineNum":"  272","line":""},
{"lineNum":"  273","line":"            // Combine all bits from buffer with enough bits from this rounds byte so that they fill"},
{"lineNum":"  274","line":"            // a u5. Save reamining bits from byte to buffer."},
{"lineNum":"  275","line":"            let from_buffer = buffer >> 3;","class":"linePartCov","hits":"1","order":"4177","possible_hits":"2",},
{"lineNum":"  276","line":"            let from_byte = b >> (3 + buffer_bits); // buffer_bits <= 4","class":"linePartCov","hits":"1","order":"4178","possible_hits":"4",},
{"lineNum":"  277","line":""},
{"lineNum":"  278","line":"            writer.write_u5(u5(from_buffer | from_byte))?;","class":"linePartCov","hits":"1","order":"4179","possible_hits":"2",},
{"lineNum":"  279","line":"            buffer = b << (5 - buffer_bits);","class":"linePartCov","hits":"1","order":"4180","possible_hits":"4",},
{"lineNum":"  280","line":"            buffer_bits = 3 + buffer_bits;","class":"linePartCov","hits":"1","order":"4181","possible_hits":"4",},
{"lineNum":"  281","line":"        }"},
{"lineNum":"  282","line":""},
{"lineNum":"  283","line":"        // There can be at most two u5s left in the buffer after processing all bytes, write them."},
{"lineNum":"  284","line":"        if buffer_bits >= 5 {","class":"linePartCov","hits":"1","order":"4185","possible_hits":"2",},
{"lineNum":"  285","line":"            writer.write_u5(u5((buffer & 0b11111000) >> 3))?;","class":"linePartCov","hits":"1","order":"4186","possible_hits":"2",},
{"lineNum":"  286","line":"            buffer = buffer << 5;","class":"linePartCov","hits":"1","order":"4187","possible_hits":"2",},
{"lineNum":"  287","line":"            buffer_bits -= 5;","class":"linePartCov","hits":"1","order":"4188","possible_hits":"4",},
{"lineNum":"  288","line":"        }"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"        if buffer_bits != 0 {","class":"linePartCov","hits":"2","order":"4189","possible_hits":"4",},
{"lineNum":"  291","line":"            writer.write_u5(u5(buffer >> 3))?;","class":"linePartCov","hits":"1","order":"4190","possible_hits":"2",},
{"lineNum":"  292","line":"        }"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"        Ok(())","class":"linePartCov","hits":"1","order":"4191","possible_hits":"2",},
{"lineNum":"  295","line":"    }","class":"linePartCov","hits":"2","order":"4192","possible_hits":"4",},
{"lineNum":"  296","line":"}"},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"impl<T: AsRef<[u8]>> Base32Len for T {"},
{"lineNum":"  299","line":"    fn base32_len(&self) -> usize {","class":"lineCov","hits":"1","order":"4153","possible_hits":"1",},
{"lineNum":"  300","line":"        let bits = self.as_ref().len() * 8;","class":"linePartCov","hits":"1","order":"4154","possible_hits":"2",},
{"lineNum":"  301","line":"        if bits % 5 == 0 {","class":"linePartCov","hits":"1","order":"4157","possible_hits":"2",},
{"lineNum":"  302","line":"            bits / 5","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  303","line":"        } else {"},
{"lineNum":"  304","line":"            bits / 5 + 1","class":"linePartCov","hits":"2","order":"4158","possible_hits":"4",},
{"lineNum":"  305","line":"        }"},
{"lineNum":"  306","line":"    }","class":"lineCov","hits":"1","order":"4159","possible_hits":"1",},
{"lineNum":"  307","line":"}"},
{"lineNum":"  308","line":""},
{"lineNum":"  309","line":"/// A trait to convert between u8 arrays and u5 arrays without changing the content of the elements,"},
{"lineNum":"  310","line":"/// but checking that they are in range."},
{"lineNum":"  311","line":"pub trait CheckBase32<T: AsRef<[u5]>> {"},
{"lineNum":"  312","line":"    /// Error type if conversion fails"},
{"lineNum":"  313","line":"    type Err;"},
{"lineNum":"  314","line":""},
{"lineNum":"  315","line":"    /// Check if all values are in range and return array-like struct of `u5` values"},
{"lineNum":"  316","line":"    fn check_base32(self) -> Result<T, Self::Err>;"},
{"lineNum":"  317","line":"}"},
{"lineNum":"  318","line":""},
{"lineNum":"  319","line":"impl<\'f, T: AsRef<[u8]>> CheckBase32<Vec<u5>> for T {"},
{"lineNum":"  320","line":"    type Err = Error;"},
{"lineNum":"  321","line":""},
{"lineNum":"  322","line":"    fn check_base32(self) -> Result<Vec<u5>, Self::Err> {","class":"linePartCov","hits":"1","order":"3504","possible_hits":"2",},
{"lineNum":"  323","line":"        self.as_ref()","class":"lineCov","hits":"3","order":"3505","possible_hits":"3",},
{"lineNum":"  324","line":"            .iter()"},
{"lineNum":"  325","line":"            .map(|x| u5::try_from_u8(*x))","class":"lineCov","hits":"2","order":"3526","possible_hits":"2",},
{"lineNum":"  326","line":"            .collect::<Result<Vec<u5>, Error>>()"},
{"lineNum":"  327","line":"    }","class":"linePartCov","hits":"1","order":"3527","possible_hits":"2",},
{"lineNum":"  328","line":"}"},
{"lineNum":"  329","line":""},
{"lineNum":"  330","line":"#[derive(Clone, Copy, PartialEq, Eq)]"},
{"lineNum":"  331","line":"enum Case {"},
{"lineNum":"  332","line":"    Upper,"},
{"lineNum":"  333","line":"    Lower,"},
{"lineNum":"  334","line":"    None,"},
{"lineNum":"  335","line":"}"},
{"lineNum":"  336","line":""},
{"lineNum":"  337","line":"/// Check if the HRP is valid. Returns the case of the HRP, if any."},
{"lineNum":"  338","line":"///"},
{"lineNum":"  339","line":"/// # Errors"},
{"lineNum":"  340","line":"/// * **MixedCase**: If the HRP contains both uppercase and lowercase characters."},
{"lineNum":"  341","line":"/// * **InvalidChar**: If the HRP contains any non-ASCII characters (outside 33..=126)."},
{"lineNum":"  342","line":"/// * **InvalidLength**: If the HRP is outside 1..83 characters long."},
{"lineNum":"  343","line":"fn check_hrp(hrp: &str) -> Result<Case, Error> {","class":"lineCov","hits":"1","order":"3127","possible_hits":"1",},
{"lineNum":"  344","line":"    if hrp.is_empty() || hrp.len() > 83 {","class":"lineCov","hits":"1","order":"3128","possible_hits":"1",},
{"lineNum":"  345","line":"        return Err(Error::InvalidLength);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  346","line":"    }"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"    let mut has_lower: bool = false;","class":"lineCov","hits":"1","order":"3132","possible_hits":"1",},
{"lineNum":"  349","line":"    let mut has_upper: bool = false;","class":"lineCov","hits":"1","order":"3133","possible_hits":"1",},
{"lineNum":"  350","line":"    for b in hrp.bytes() {","class":"linePartCov","hits":"3","order":"3134","possible_hits":"4",},
{"lineNum":"  351","line":"        // Valid subset of ASCII"},
{"lineNum":"  352","line":"        if b < 33 || b > 126 {","class":"lineCov","hits":"1","order":"3143","possible_hits":"1",},
{"lineNum":"  353","line":"            return Err(Error::InvalidChar(b as char));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  354","line":"        }"},
{"lineNum":"  355","line":""},
{"lineNum":"  356","line":"        if b >= b\'a\' && b <= b\'z\' {","class":"linePartCov","hits":"3","order":"3144","possible_hits":"4",},
{"lineNum":"  357","line":"            has_lower = true;","class":"lineCov","hits":"1","order":"3145","possible_hits":"1",},
{"lineNum":"  358","line":"        } else if b >= b\'A\' && b <= b\'Z\' {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  359","line":"            has_upper = true;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  360","line":"        };"},
{"lineNum":"  361","line":""},
{"lineNum":"  362","line":"        if has_lower && has_upper {","class":"lineCov","hits":"1","order":"3146","possible_hits":"1",},
{"lineNum":"  363","line":"            return Err(Error::MixedCase);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  364","line":"        }"},
{"lineNum":"  365","line":"    }"},
{"lineNum":"  366","line":""},
{"lineNum":"  367","line":"    Ok(match (has_upper, has_lower) {","class":"linePartCov","hits":"3","order":"3147","possible_hits":"4",},
{"lineNum":"  368","line":"        (true, false) => Case::Upper,","class":"linePartCov","hits":"1","order":"3148","possible_hits":"3",},
{"lineNum":"  369","line":"        (false, true) => Case::Lower,","class":"lineCov","hits":"2","order":"3149","possible_hits":"2",},
{"lineNum":"  370","line":"        (false, false) => Case::None,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  371","line":"        (true, true) => unreachable!(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  372","line":"    })"},
{"lineNum":"  373","line":"}","class":"linePartCov","hits":"2","order":"3150","possible_hits":"3",},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"/// Encode a bech32 payload to an [fmt::Write]."},
{"lineNum":"  376","line":"/// This method is intended for implementing traits from [std::fmt]."},
{"lineNum":"  377","line":"///"},
{"lineNum":"  378","line":"/// # Errors"},
{"lineNum":"  379","line":"/// * If [check_hrp] returns an error for the given HRP."},
{"lineNum":"  380","line":"/// # Deviations from standard"},
{"lineNum":"  381","line":"/// * No length limits are enforced for the data part"},
{"lineNum":"  382","line":"pub fn encode_to_fmt<T: AsRef<[u5]>>("},
{"lineNum":"  383","line":"    fmt: &mut fmt::Write,"},
{"lineNum":"  384","line":"    hrp: &str,"},
{"lineNum":"  385","line":"    data: T,"},
{"lineNum":"  386","line":") -> Result<fmt::Result, Error> {"},
{"lineNum":"  387","line":"    let hrp_lower = match check_hrp(&hrp)? {"},
{"lineNum":"  388","line":"        Case::Upper => Cow::Owned(hrp.to_lowercase()),"},
{"lineNum":"  389","line":"        Case::Lower | Case::None => Cow::Borrowed(hrp),"},
{"lineNum":"  390","line":"    };"},
{"lineNum":"  391","line":""},
{"lineNum":"  392","line":"    match Bech32Writer::new(&hrp_lower, fmt) {"},
{"lineNum":"  393","line":"        Ok(mut writer) => {"},
{"lineNum":"  394","line":"            Ok(writer.write(data.as_ref()).and_then(|_| {"},
{"lineNum":"  395","line":"                // Finalize manually to avoid panic on drop if write fails"},
{"lineNum":"  396","line":"                writer.finalize()"},
{"lineNum":"  397","line":"            }))"},
{"lineNum":"  398","line":"        }"},
{"lineNum":"  399","line":"        Err(e) => Ok(Err(e)),"},
{"lineNum":"  400","line":"    }"},
{"lineNum":"  401","line":"}"},
{"lineNum":"  402","line":""},
{"lineNum":"  403","line":"/// Encode a bech32 payload to string."},
{"lineNum":"  404","line":"///"},
{"lineNum":"  405","line":"/// # Errors"},
{"lineNum":"  406","line":"/// * If [check_hrp] returns an error for the given HRP."},
{"lineNum":"  407","line":"/// # Deviations from standard"},
{"lineNum":"  408","line":"/// * No length limits are enforced for the data part"},
{"lineNum":"  409","line":"pub fn encode<T: AsRef<[u5]>>(hrp: &str, data: T) -> Result<String, Error> {"},
{"lineNum":"  410","line":"    let mut buf = String::new();"},
{"lineNum":"  411","line":"    encode_to_fmt(&mut buf, hrp, data)?.unwrap();"},
{"lineNum":"  412","line":"    Ok(buf)"},
{"lineNum":"  413","line":"}"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"/// Decode a bech32 string into the raw HRP and the data bytes."},
{"lineNum":"  416","line":"///"},
{"lineNum":"  417","line":"/// Returns the HRP in lowercase.."},
{"lineNum":"  418","line":"pub fn decode(s: &str) -> Result<(String, Vec<u5>), Error> {","class":"linePartCov","hits":"1","order":"2994","possible_hits":"2",},
{"lineNum":"  419","line":"    // Ensure overall length is within bounds"},
{"lineNum":"  420","line":"    if s.len() < 8 {","class":"lineCov","hits":"2","order":"2995","possible_hits":"2",},
{"lineNum":"  421","line":"        return Err(Error::InvalidLength);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  422","line":"    }"},
{"lineNum":"  423","line":""},
{"lineNum":"  424","line":"    // Split at separator and check for two pieces"},
{"lineNum":"  425","line":"    let (raw_hrp, raw_data) = match s.rfind(SEP) {","class":"linePartCov","hits":"2","order":"2996","possible_hits":"3",},
{"lineNum":"  426","line":"        None => return Err(Error::MissingSeparator),","class":"linePartCov","hits":"1","order":"3068","possible_hits":"2",},
{"lineNum":"  427","line":"        Some(sep) => {","class":"lineCov","hits":"1","order":"3069","possible_hits":"1",},
{"lineNum":"  428","line":"            let (hrp, data) = s.split_at(sep);","class":"lineCov","hits":"2","order":"3070","possible_hits":"2",},
{"lineNum":"  429","line":"            (hrp, &data[1..])","class":"lineCov","hits":"1","order":"3104","possible_hits":"1",},
{"lineNum":"  430","line":"        }"},
{"lineNum":"  431","line":"    };"},
{"lineNum":"  432","line":"    if raw_data.len() < 6 {","class":"lineCov","hits":"1","order":"3125","possible_hits":"1",},
{"lineNum":"  433","line":"        return Err(Error::InvalidLength);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  434","line":"    }"},
{"lineNum":"  435","line":""},
{"lineNum":"  436","line":"    let mut case = check_hrp(&raw_hrp)?;","class":"linePartCov","hits":"2","order":"3126","possible_hits":"3",},
{"lineNum":"  437","line":"    let hrp_lower = match case {","class":"linePartCov","hits":"1","order":"3175","possible_hits":"3",},
{"lineNum":"  438","line":"        Case::Upper => raw_hrp.to_lowercase(),","class":"linePartCov","hits":"1","order":"3151","possible_hits":"2",},
{"lineNum":"  439","line":"        // already lowercase"},
{"lineNum":"  440","line":"        Case::Lower | Case::None => String::from(raw_hrp),","class":"lineCov","hits":"1","order":"3152","possible_hits":"1",},
{"lineNum":"  441","line":"    };"},
{"lineNum":"  442","line":""},
{"lineNum":"  443","line":"    // Check data payload"},
{"lineNum":"  444","line":"    let mut data = raw_data","class":"linePartCov","hits":"4","order":"3176","possible_hits":"5",},
{"lineNum":"  445","line":"        .chars()"},
{"lineNum":"  446","line":"        .map(|c| {","class":"lineCov","hits":"2","order":"3180","possible_hits":"2",},
{"lineNum":"  447","line":"            // Only check if c is in the ASCII range, all invalid ASCII"},
{"lineNum":"  448","line":"            // characters have the value -1 in CHARSET_REV (which covers"},
{"lineNum":"  449","line":"            // the whole ASCII range) and will be filtered out later."},
{"lineNum":"  450","line":"            if !c.is_ascii() {","class":"lineCov","hits":"1","order":"3210","possible_hits":"1",},
{"lineNum":"  451","line":"                return Err(Error::InvalidChar(c));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  452","line":"            }"},
{"lineNum":"  453","line":""},
{"lineNum":"  454","line":"            if c.is_lowercase() {","class":"lineCov","hits":"3","order":"3214","possible_hits":"3",},
{"lineNum":"  455","line":"                match case {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  456","line":"                    Case::Upper => return Err(Error::MixedCase),","class":"linePartCov","hits":"1","order":"3219","possible_hits":"2",},
{"lineNum":"  457","line":"                    Case::None => case = Case::Lower,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  458","line":"                    Case::Lower => {}"},
{"lineNum":"  459","line":"                }"},
{"lineNum":"  460","line":"            } else if c.is_uppercase() {","class":"lineCov","hits":"2","order":"3283","possible_hits":"2",},
{"lineNum":"  461","line":"                match case {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  462","line":"                    Case::Lower => return Err(Error::MixedCase),","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  463","line":"                    Case::None => case = Case::Upper,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  464","line":"                    Case::Upper => {}"},
{"lineNum":"  465","line":"                }"},
{"lineNum":"  466","line":"            }"},
{"lineNum":"  467","line":""},
{"lineNum":"  468","line":"            // c should be <128 since it is in the ASCII range, CHARSET_REV.len() == 128"},
{"lineNum":"  469","line":"            let num_value = CHARSET_REV[c as usize];","class":"linePartCov","hits":"1","order":"3220","possible_hits":"3",},
{"lineNum":"  470","line":""},
{"lineNum":"  471","line":"            if num_value > 31 || num_value < 0 {","class":"lineCov","hits":"1","order":"3221","possible_hits":"1",},
{"lineNum":"  472","line":"                return Err(Error::InvalidChar(c));","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  473","line":"            }"},
{"lineNum":"  474","line":""},
{"lineNum":"  475","line":"            Ok(u5::try_from_u8(num_value as u8).expect(\"range checked above, num_value <= 31\"))","class":"lineCov","hits":"2","order":"3222","possible_hits":"2",},
{"lineNum":"  476","line":"        })","class":"lineCov","hits":"2","order":"3223","possible_hits":"2",},
{"lineNum":"  477","line":"        .collect::<Result<Vec<u5>, Error>>()?;","class":"linePartCov","hits":"1","order":"3293","possible_hits":"3",},
{"lineNum":"  478","line":""},
{"lineNum":"  479","line":"    // Ensure checksum"},
{"lineNum":"  480","line":"    if !verify_checksum(&hrp_lower.as_bytes(), &data) {","class":"lineCov","hits":"2","order":"3294","possible_hits":"2",},
{"lineNum":"  481","line":"        return Err(Error::InvalidChecksum);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  482","line":"    }"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"    // Remove checksum from data payload"},
{"lineNum":"  485","line":"    let dbl: usize = data.len();","class":"lineCov","hits":"2","order":"3343","possible_hits":"2",},
{"lineNum":"  486","line":"    data.truncate(dbl - 6);","class":"linePartCov","hits":"1","order":"3345","possible_hits":"2",},
{"lineNum":"  487","line":""},
{"lineNum":"  488","line":"    Ok((hrp_lower, data))","class":"lineCov","hits":"1","order":"3350","possible_hits":"1",},
{"lineNum":"  489","line":"}","class":"linePartCov","hits":"2","order":"3351","possible_hits":"6",},
{"lineNum":"  490","line":""},
{"lineNum":"  491","line":"fn verify_checksum(hrp: &[u8], data: &[u5]) -> bool {","class":"linePartCov","hits":"1","order":"3298","possible_hits":"2",},
{"lineNum":"  492","line":"    let mut exp = hrp_expand(hrp);","class":"lineCov","hits":"1","order":"3299","possible_hits":"1",},
{"lineNum":"  493","line":"    exp.extend_from_slice(data);","class":"lineCov","hits":"1","order":"3310","possible_hits":"1",},
{"lineNum":"  494","line":"    polymod(&exp) == 1u32","class":"lineCov","hits":"2","order":"3313","possible_hits":"2",},
{"lineNum":"  495","line":"}","class":"linePartCov","hits":"1","order":"3341","possible_hits":"2",},
{"lineNum":"  496","line":""},
{"lineNum":"  497","line":"fn hrp_expand(hrp: &[u8]) -> Vec<u5> {","class":"linePartCov","hits":"1","order":"3300","possible_hits":"2",},
{"lineNum":"  498","line":"    let mut v: Vec<u5> = Vec::new();","class":"lineCov","hits":"1","order":"3301","possible_hits":"1",},
{"lineNum":"  499","line":"    for b in hrp {","class":"linePartCov","hits":"3","order":"3302","possible_hits":"4",},
{"lineNum":"  500","line":"        v.push(u5::try_from_u8(*b >> 5).expect(\"can\'t be out of range, max. 7\"));","class":"lineCov","hits":"1","order":"3303","possible_hits":"1",},
{"lineNum":"  501","line":"    }"},
{"lineNum":"  502","line":"    v.push(u5::try_from_u8(0).unwrap());","class":"lineCov","hits":"2","order":"3304","possible_hits":"2",},
{"lineNum":"  503","line":"    for b in hrp {","class":"linePartCov","hits":"2","order":"3305","possible_hits":"3",},
{"lineNum":"  504","line":"        v.push(u5::try_from_u8(*b & 0x1f).expect(\"can\'t be out of range, max. 31\"));","class":"lineCov","hits":"1","order":"3306","possible_hits":"1",},
{"lineNum":"  505","line":"    }"},
{"lineNum":"  506","line":"    v","class":"lineCov","hits":"1","order":"3307","possible_hits":"1",},
{"lineNum":"  507","line":"}","class":"linePartCov","hits":"1","order":"3309","possible_hits":"2",},
{"lineNum":"  508","line":""},
{"lineNum":"  509","line":"fn polymod(values: &[u5]) -> u32 {","class":"lineCov","hits":"1","order":"3314","possible_hits":"1",},
{"lineNum":"  510","line":"    let mut chk: u32 = 1;","class":"lineCov","hits":"1","order":"3315","possible_hits":"1",},
{"lineNum":"  511","line":"    let mut b: u8;"},
{"lineNum":"  512","line":"    for v in values {","class":"linePartCov","hits":"2","order":"3316","possible_hits":"3",},
{"lineNum":"  513","line":"        b = (chk >> 25) as u8;","class":"lineCov","hits":"1","order":"3317","possible_hits":"1",},
{"lineNum":"  514","line":"        chk = (chk & 0x1ffffff) << 5 ^ (u32::from(*v.as_ref()));","class":"lineCov","hits":"1","order":"3318","possible_hits":"1",},
{"lineNum":"  515","line":"        for i in 0..5 {","class":"linePartCov","hits":"2","order":"3321","possible_hits":"3",},
{"lineNum":"  516","line":"            if (b >> i) & 1 == 1 {","class":"linePartCov","hits":"1","order":"3332","possible_hits":"2",},
{"lineNum":"  517","line":"                chk ^= GEN[i]","class":"linePartCov","hits":"1","order":"3337","possible_hits":"3",},
{"lineNum":"  518","line":"            }"},
{"lineNum":"  519","line":"        }"},
{"lineNum":"  520","line":"    }"},
{"lineNum":"  521","line":"    chk","class":"lineCov","hits":"1","order":"3338","possible_hits":"1",},
{"lineNum":"  522","line":"}","class":"lineCov","hits":"1","order":"3339","possible_hits":"1",},
{"lineNum":"  523","line":""},
{"lineNum":"  524","line":"/// Human-readable part and data part separator"},
{"lineNum":"  525","line":"const SEP: char = \'1\';"},
{"lineNum":"  526","line":""},
{"lineNum":"  527","line":"/// Encoding character set. Maps data value -> char"},
{"lineNum":"  528","line":"const CHARSET: [char; 32] = ["},
{"lineNum":"  529","line":"    \'q\',\'p\',\'z\',\'r\',\'y\',\'9\',\'x\',\'8\',"},
{"lineNum":"  530","line":"    \'g\',\'f\',\'2\',\'t\',\'v\',\'d\',\'w\',\'0\',"},
{"lineNum":"  531","line":"    \'s\',\'3\',\'j\',\'n\',\'5\',\'4\',\'k\',\'h\',"},
{"lineNum":"  532","line":"    \'c\',\'e\',\'6\',\'m\',\'u\',\'a\',\'7\',\'l\'"},
{"lineNum":"  533","line":"];"},
{"lineNum":"  534","line":""},
{"lineNum":"  535","line":"/// Reverse character set. Maps ASCII byte -> CHARSET index on [0,31]"},
{"lineNum":"  536","line":"const CHARSET_REV: [i8; 128] = ["},
{"lineNum":"  537","line":"    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,"},
{"lineNum":"  538","line":"    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,"},
{"lineNum":"  539","line":"    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,"},
{"lineNum":"  540","line":"    15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,"},
{"lineNum":"  541","line":"    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,"},
{"lineNum":"  542","line":"     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,"},
{"lineNum":"  543","line":"    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,"},
{"lineNum":"  544","line":"    1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1"},
{"lineNum":"  545","line":"];"},
{"lineNum":"  546","line":""},
{"lineNum":"  547","line":"/// Generator coefficients"},
{"lineNum":"  548","line":"const GEN: [u32; 5] = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];"},
{"lineNum":"  549","line":""},
{"lineNum":"  550","line":"/// Error types for Bech32 encoding / decoding"},
{"lineNum":"  551","line":"#[derive(Copy, Clone, PartialEq, Debug)]","class":"lineNoCov","hits":"0","possible_hits":"10",},
{"lineNum":"  552","line":"pub enum Error {"},
{"lineNum":"  553","line":"    /// String does not contain the separator character"},
{"lineNum":"  554","line":"    MissingSeparator,"},
{"lineNum":"  555","line":"    /// The checksum does not match the rest of the data"},
{"lineNum":"  556","line":"    InvalidChecksum,"},
{"lineNum":"  557","line":"    /// The data or human-readable part is too long or too short"},
{"lineNum":"  558","line":"    InvalidLength,"},
{"lineNum":"  559","line":"    /// Some part of the string contains an invalid character"},
{"lineNum":"  560","line":"    InvalidChar(char),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  561","line":"    /// Some part of the data has an invalid value"},
{"lineNum":"  562","line":"    InvalidData(u8),","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  563","line":"    /// The bit conversion failed due to a padding issue"},
{"lineNum":"  564","line":"    InvalidPadding,"},
{"lineNum":"  565","line":"    /// The whole string must be of one case"},
{"lineNum":"  566","line":"    MixedCase,"},
{"lineNum":"  567","line":"}"},
{"lineNum":"  568","line":""},
{"lineNum":"  569","line":"impl fmt::Display for Error {"},
{"lineNum":"  570","line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  571","line":"        match *self {"},
{"lineNum":"  572","line":"            Error::MissingSeparator => write!(f, \"missing human-readable separator, \\\"{}\\\"\", SEP),"},
{"lineNum":"  573","line":"            Error::InvalidChecksum => write!(f, \"invalid checksum\"),"},
{"lineNum":"  574","line":"            Error::InvalidLength => write!(f, \"invalid length\"),"},
{"lineNum":"  575","line":"            Error::InvalidChar(n) => write!(f, \"invalid character (code={})\", n),"},
{"lineNum":"  576","line":"            Error::InvalidData(n) => write!(f, \"invalid data point ({})\", n),"},
{"lineNum":"  577","line":"            Error::InvalidPadding => write!(f, \"invalid padding\"),"},
{"lineNum":"  578","line":"            Error::MixedCase => write!(f, \"mixed-case strings not allowed\"),"},
{"lineNum":"  579","line":"        }"},
{"lineNum":"  580","line":"    }"},
{"lineNum":"  581","line":"}"},
{"lineNum":"  582","line":""},
{"lineNum":"  583","line":"impl error::Error for Error {"},
{"lineNum":"  584","line":"    fn description(&self) -> &str {"},
{"lineNum":"  585","line":"        match *self {"},
{"lineNum":"  586","line":"            Error::MissingSeparator => \"missing human-readable separator\","},
{"lineNum":"  587","line":"            Error::InvalidChecksum => \"invalid checksum\","},
{"lineNum":"  588","line":"            Error::InvalidLength => \"invalid length\","},
{"lineNum":"  589","line":"            Error::InvalidChar(_) => \"invalid character\","},
{"lineNum":"  590","line":"            Error::InvalidData(_) => \"invalid data point\","},
{"lineNum":"  591","line":"            Error::InvalidPadding => \"invalid padding\","},
{"lineNum":"  592","line":"            Error::MixedCase => \"mixed-case strings not allowed\","},
{"lineNum":"  593","line":"        }"},
{"lineNum":"  594","line":"    }"},
{"lineNum":"  595","line":"}"},
{"lineNum":"  596","line":""},
{"lineNum":"  597","line":"/// Convert between bit sizes"},
{"lineNum":"  598","line":"///"},
{"lineNum":"  599","line":"/// # Errors"},
{"lineNum":"  600","line":"/// * `Error::InvalidData` if any element of `data` is out of range"},
{"lineNum":"  601","line":"/// * `Error::InvalidPadding` if `pad == false` and the padding bits are not `0`"},
{"lineNum":"  602","line":"///"},
{"lineNum":"  603","line":"/// # Panics"},
{"lineNum":"  604","line":"/// Function will panic if attempting to convert `from` or `to` a bit size that"},
{"lineNum":"  605","line":"/// is 0 or larger than 8 bits."},
{"lineNum":"  606","line":"///"},
{"lineNum":"  607","line":"/// # Examples"},
{"lineNum":"  608","line":"///"},
{"lineNum":"  609","line":"/// ```rust"},
{"lineNum":"  610","line":"/// use bech32::convert_bits;"},
{"lineNum":"  611","line":"/// let base5 = convert_bits(&[0xff], 8, 5, true);"},
{"lineNum":"  612","line":"/// assert_eq!(base5.unwrap(), vec![0x1f, 0x1c]);"},
{"lineNum":"  613","line":"/// ```"},
{"lineNum":"  614","line":"pub fn convert_bits<T>(data: &[T], from: u32, to: u32, pad: bool) -> Result<Vec<u8>, Error>","class":"linePartCov","hits":"1","order":"2008","possible_hits":"2",},
{"lineNum":"  615","line":"where"},
{"lineNum":"  616","line":"    T: Into<u8> + Copy,"},
{"lineNum":"  617","line":"{"},
{"lineNum":"  618","line":"    if from > 8 || to > 8 || from == 0 || to == 0 {","class":"lineCov","hits":"1","order":"2009","possible_hits":"1",},
{"lineNum":"  619","line":"        panic!(\"convert_bits `from` and `to` parameters 0 or greater than 8\");","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  620","line":"    }"},
{"lineNum":"  621","line":"    let mut acc: u32 = 0;","class":"lineCov","hits":"1","order":"2010","possible_hits":"1",},
{"lineNum":"  622","line":"    let mut bits: u32 = 0;","class":"lineCov","hits":"1","order":"2011","possible_hits":"1",},
{"lineNum":"  623","line":"    let mut ret: Vec<u8> = Vec::new();","class":"lineCov","hits":"1","order":"2012","possible_hits":"1",},
{"lineNum":"  624","line":"    let maxv: u32 = (1 << to) - 1;","class":"linePartCov","hits":"2","order":"2013","possible_hits":"3",},
{"lineNum":"  625","line":"    for value in data {","class":"linePartCov","hits":"2","order":"2014","possible_hits":"3",},
{"lineNum":"  626","line":"        let v: u32 = u32::from(Into::<u8>::into(*value));","class":"lineCov","hits":"1","order":"2018","possible_hits":"1",},
{"lineNum":"  627","line":"        if (v >> from) != 0 {","class":"linePartCov","hits":"1","order":"2024","possible_hits":"2",},
{"lineNum":"  628","line":"            // Input value exceeds `from` bit size"},
{"lineNum":"  629","line":"            return Err(Error::InvalidData(v as u8));","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  630","line":"        }"},
{"lineNum":"  631","line":"        acc = (acc << from) | v;","class":"linePartCov","hits":"2","order":"2025","possible_hits":"3",},
{"lineNum":"  632","line":"        bits += from;","class":"linePartCov","hits":"1","order":"2026","possible_hits":"2",},
{"lineNum":"  633","line":"        while bits >= to {","class":"lineCov","hits":"2","order":"2027","possible_hits":"2",},
{"lineNum":"  634","line":"            bits -= to;","class":"linePartCov","hits":"1","order":"2028","possible_hits":"2",},
{"lineNum":"  635","line":"            ret.push(((acc >> bits) & maxv) as u8);","class":"linePartCov","hits":"1","order":"2029","possible_hits":"2",},
{"lineNum":"  636","line":"        }"},
{"lineNum":"  637","line":"    }"},
{"lineNum":"  638","line":"    if pad {","class":"linePartCov","hits":"2","order":"2071","possible_hits":"3",},
{"lineNum":"  639","line":"        if bits > 0 {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  640","line":"            ret.push(((acc << (to - bits)) & maxv) as u8);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  641","line":"        }"},
{"lineNum":"  642","line":"    } else if bits >= from || ((acc << (to - bits)) & maxv) != 0 {","class":"linePartCov","hits":"1","order":"2072","possible_hits":"3",},
{"lineNum":"  643","line":"        return Err(Error::InvalidPadding);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  644","line":"    }"},
{"lineNum":"  645","line":"    Ok(ret)","class":"lineCov","hits":"1","order":"2073","possible_hits":"1",},
{"lineNum":"  646","line":"}","class":"linePartCov","hits":"2","order":"2074","possible_hits":"3",},
{"lineNum":"  647","line":""},
{"lineNum":"  648","line":"#[cfg(test)]"},
{"lineNum":"  649","line":"mod tests {"},
{"lineNum":"  650","line":"    use super::*;"},
{"lineNum":"  651","line":""},
{"lineNum":"  652","line":"    #[test]"},
{"lineNum":"  653","line":"    fn getters() {"},
{"lineNum":"  654","line":"        let decoded = decode(\"BC1SW50QA3JX3S\").unwrap();"},
{"lineNum":"  655","line":"        let data = [16, 14, 20, 15, 0].check_base32().unwrap();"},
{"lineNum":"  656","line":"        assert_eq!(&decoded.0, \"bc\");"},
{"lineNum":"  657","line":"        assert_eq!(decoded.1, data.as_slice());"},
{"lineNum":"  658","line":"    }"},
{"lineNum":"  659","line":""},
{"lineNum":"  660","line":"    #[test]"},
{"lineNum":"  661","line":"    fn valid_checksum() {"},
{"lineNum":"  662","line":"        let strings: Vec<&str> = vec!("},
{"lineNum":"  663","line":"            \"A12UEL5L\","},
{"lineNum":"  664","line":"            \"an83characterlonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1tt5tgs\","},
{"lineNum":"  665","line":"            \"abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw\","},
{"lineNum":"  666","line":"            \"11qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqc8247j\","},
{"lineNum":"  667","line":"            \"split1checkupstagehandshakeupstreamerranterredcaperred2y9e3w\","},
{"lineNum":"  668","line":"        );"},
{"lineNum":"  669","line":"        for s in strings {"},
{"lineNum":"  670","line":"            let decode_result = decode(s);"},
{"lineNum":"  671","line":"            if !decode_result.is_ok() {"},
{"lineNum":"  672","line":"                panic!(\"Did not decode: {:?} Reason: {:?}\", s, decode_result.unwrap_err());"},
{"lineNum":"  673","line":"            }"},
{"lineNum":"  674","line":"            assert!(decode_result.is_ok());"},
{"lineNum":"  675","line":"            let decoded = decode_result.unwrap();"},
{"lineNum":"  676","line":"            let encode_result = encode(&decoded.0, decoded.1).unwrap();"},
{"lineNum":"  677","line":"            assert_eq!(s.to_lowercase(), encode_result.to_lowercase());"},
{"lineNum":"  678","line":"        }"},
{"lineNum":"  679","line":"    }"},
{"lineNum":"  680","line":""},
{"lineNum":"  681","line":"    #[test]"},
{"lineNum":"  682","line":"    fn invalid_strings() {"},
{"lineNum":"  683","line":"        let pairs: Vec<(&str, Error)> = vec!("},
{"lineNum":"  684","line":"            (\" 1nwldj5\","},
{"lineNum":"  685","line":"                Error::InvalidChar(\' \')),"},
{"lineNum":"  686","line":"            (\"abc1\\u{2192}axkwrx\","},
{"lineNum":"  687","line":"                Error::InvalidChar(\'\\u{2192}\')),"},
{"lineNum":"  688","line":"            (\"an84characterslonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1569pvx\","},
{"lineNum":"  689","line":"                Error::InvalidLength),"},
{"lineNum":"  690","line":"            (\"pzry9x0s0muk\","},
{"lineNum":"  691","line":"                Error::MissingSeparator),"},
{"lineNum":"  692","line":"            (\"1pzry9x0s0muk\","},
{"lineNum":"  693","line":"                Error::InvalidLength),"},
{"lineNum":"  694","line":"            (\"x1b4n0q5v\","},
{"lineNum":"  695","line":"                Error::InvalidChar(\'b\')),"},
{"lineNum":"  696","line":"            (\"ABC1DEFGOH\","},
{"lineNum":"  697","line":"                Error::InvalidChar(\'O\')),"},
{"lineNum":"  698","line":"            (\"li1dgmt3\","},
{"lineNum":"  699","line":"                Error::InvalidLength),"},
{"lineNum":"  700","line":"            (\"de1lg7wt\\u{ff}\","},
{"lineNum":"  701","line":"                Error::InvalidChar(\'\\u{ff}\')),"},
{"lineNum":"  702","line":"        );"},
{"lineNum":"  703","line":"        for p in pairs {"},
{"lineNum":"  704","line":"            let (s, expected_error) = p;"},
{"lineNum":"  705","line":"            let dec_result = decode(s);"},
{"lineNum":"  706","line":"            if dec_result.is_ok() {"},
{"lineNum":"  707","line":"                println!(\"{:?}\", dec_result.unwrap());"},
{"lineNum":"  708","line":"                panic!(\"Should be invalid: {:?}\", s);"},
{"lineNum":"  709","line":"            }"},
{"lineNum":"  710","line":"            assert_eq!(dec_result.unwrap_err(), expected_error, \"testing input \'{}\'\", s);"},
{"lineNum":"  711","line":"        }"},
{"lineNum":"  712","line":"    }"},
{"lineNum":"  713","line":""},
{"lineNum":"  714","line":"    #[test]"},
{"lineNum":"  715","line":"    fn valid_conversion() {"},
{"lineNum":"  716","line":"        // Set of [data, from_bits, to_bits, pad, result]"},
{"lineNum":"  717","line":"        let tests: Vec<(Vec<u8>, u32, u32, bool, Vec<u8>)> = vec!["},
{"lineNum":"  718","line":"            (vec![0x01], 1, 1, true, vec![0x01]),"},
{"lineNum":"  719","line":"            (vec![0x01, 0x01], 1, 1, true, vec![0x01, 0x01]),"},
{"lineNum":"  720","line":"            (vec![0x01], 8, 8, true, vec![0x01]),"},
{"lineNum":"  721","line":"            (vec![0x01], 8, 4, true, vec![0x00, 0x01]),"},
{"lineNum":"  722","line":"            (vec![0x01], 8, 2, true, vec![0x00, 0x00, 0x00, 0x01]),"},
{"lineNum":"  723","line":"            (vec![0x01], 8, 1, true, vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]),"},
{"lineNum":"  724","line":"            (vec![0xff], 8, 5, true, vec![0x1f, 0x1c]),"},
{"lineNum":"  725","line":"            (vec![0x1f, 0x1c], 5, 8, false, vec![0xff]),"},
{"lineNum":"  726","line":"        ];"},
{"lineNum":"  727","line":"        for t in tests {"},
{"lineNum":"  728","line":"            let (data, from_bits, to_bits, pad, expected_result) = t;"},
{"lineNum":"  729","line":"            let result = convert_bits(&data, from_bits, to_bits, pad);"},
{"lineNum":"  730","line":"            assert!(result.is_ok());"},
{"lineNum":"  731","line":"            assert_eq!(result.unwrap(), expected_result);"},
{"lineNum":"  732","line":"        }"},
{"lineNum":"  733","line":"    }"},
{"lineNum":"  734","line":""},
{"lineNum":"  735","line":"    #[test]"},
{"lineNum":"  736","line":"    fn invalid_conversion() {"},
{"lineNum":"  737","line":"        // Set of [data, from_bits, to_bits, pad, expected error]"},
{"lineNum":"  738","line":"        let tests: Vec<(Vec<u8>, u32, u32, bool, Error)> = vec!["},
{"lineNum":"  739","line":"            (vec![0xff], 8, 5, false, Error::InvalidPadding),"},
{"lineNum":"  740","line":"            (vec![0x02], 1, 1, true, Error::InvalidData(0x02)),"},
{"lineNum":"  741","line":"        ];"},
{"lineNum":"  742","line":"        for t in tests {"},
{"lineNum":"  743","line":"            let (data, from_bits, to_bits, pad, expected_error) = t;"},
{"lineNum":"  744","line":"            let result = convert_bits(&data, from_bits, to_bits, pad);"},
{"lineNum":"  745","line":"            assert!(result.is_err());"},
{"lineNum":"  746","line":"            assert_eq!(result.unwrap_err(), expected_error);"},
{"lineNum":"  747","line":"        }"},
{"lineNum":"  748","line":"    }"},
{"lineNum":"  749","line":""},
{"lineNum":"  750","line":"    #[test]"},
{"lineNum":"  751","line":"    fn convert_bits_invalid_bit_size() {"},
{"lineNum":"  752","line":"        use std::panic::{catch_unwind, set_hook, take_hook};"},
{"lineNum":"  753","line":""},
{"lineNum":"  754","line":"        let invalid = &[(0, 8), (5, 0), (9, 5), (8, 10), (0, 16)];"},
{"lineNum":"  755","line":""},
{"lineNum":"  756","line":"        for &(from, to) in invalid {"},
{"lineNum":"  757","line":"            set_hook(Box::new(|_| {}));"},
{"lineNum":"  758","line":"            let result = catch_unwind(|| {"},
{"lineNum":"  759","line":"                let _ = convert_bits(&[0], from, to, true);"},
{"lineNum":"  760","line":"            });"},
{"lineNum":"  761","line":"            let _ = take_hook();"},
{"lineNum":"  762","line":"            assert!(result.is_err());"},
{"lineNum":"  763","line":"        }"},
{"lineNum":"  764","line":"    }"},
{"lineNum":"  765","line":""},
{"lineNum":"  766","line":"    #[test]"},
{"lineNum":"  767","line":"    fn check_base32() {"},
{"lineNum":"  768","line":"        assert!([0u8, 1, 2, 30, 31].check_base32().is_ok());"},
{"lineNum":"  769","line":"        assert!([0u8, 1, 2, 30, 31, 32].check_base32().is_err());"},
{"lineNum":"  770","line":"        assert!([0u8, 1, 2, 30, 31, 255].check_base32().is_err());"},
{"lineNum":"  771","line":""},
{"lineNum":"  772","line":"        assert!([1u8, 2, 3, 4].check_base32().is_ok());"},
{"lineNum":"  773","line":"        assert_eq!([30u8, 31, 35, 20].check_base32(), Err(Error::InvalidData(35)));"},
{"lineNum":"  774","line":"    }"},
{"lineNum":"  775","line":""},
{"lineNum":"  776","line":"    #[test]"},
{"lineNum":"  777","line":"    fn test_encode() {"},
{"lineNum":"  778","line":"        assert_eq!("},
{"lineNum":"  779","line":"            encode(\"\", vec![1u8, 2, 3, 4].check_base32().unwrap()),"},
{"lineNum":"  780","line":"            Err(Error::InvalidLength)"},
{"lineNum":"  781","line":"        );"},
{"lineNum":"  782","line":"    }"},
{"lineNum":"  783","line":""},
{"lineNum":"  784","line":"    #[test]"},
{"lineNum":"  785","line":"    fn from_base32() {"},
{"lineNum":"  786","line":"        use FromBase32;"},
{"lineNum":"  787","line":"        assert_eq!(Vec::from_base32(&[0x1f, 0x1c].check_base32().unwrap()), Ok(vec![0xff]));"},
{"lineNum":"  788","line":"        assert_eq!("},
{"lineNum":"  789","line":"            Vec::from_base32(&[0x1f, 0x1f].check_base32().unwrap()),"},
{"lineNum":"  790","line":"            Err(Error::InvalidPadding)"},
{"lineNum":"  791","line":"        );"},
{"lineNum":"  792","line":"    }"},
{"lineNum":"  793","line":""},
{"lineNum":"  794","line":"    #[test]"},
{"lineNum":"  795","line":"    fn to_base32() {"},
{"lineNum":"  796","line":"        use ToBase32;"},
{"lineNum":"  797","line":"        assert_eq!([0xffu8].to_base32(), [0x1f, 0x1c].check_base32().unwrap());"},
{"lineNum":"  798","line":"    }"},
{"lineNum":"  799","line":""},
{"lineNum":"  800","line":"    #[test]"},
{"lineNum":"  801","line":"    fn reverse_charset() {"},
{"lineNum":"  802","line":"        use CHARSET_REV;"},
{"lineNum":"  803","line":""},
{"lineNum":"  804","line":"        fn get_char_value(c: char) -> i8 {"},
{"lineNum":"  805","line":"            let charset = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";"},
{"lineNum":"  806","line":"            match charset.find(c.to_ascii_lowercase()) {"},
{"lineNum":"  807","line":"                Some(x) => x as i8,"},
{"lineNum":"  808","line":"                None => -1,"},
{"lineNum":"  809","line":"            }"},
{"lineNum":"  810","line":"        }"},
{"lineNum":"  811","line":""},
{"lineNum":"  812","line":"        let expected_rev_charset = (0u8..128)"},
{"lineNum":"  813","line":"            .map(|i| get_char_value(i as char))"},
{"lineNum":"  814","line":"            .collect::<Vec<_>>();"},
{"lineNum":"  815","line":""},
{"lineNum":"  816","line":"        assert_eq!(&(CHARSET_REV[..]), expected_rev_charset.as_slice());"},
{"lineNum":"  817","line":"    }"},
{"lineNum":"  818","line":""},
{"lineNum":"  819","line":"    #[test]"},
{"lineNum":"  820","line":"    fn writer() {"},
{"lineNum":"  821","line":"        let hrp = \"lnbc\";"},
{"lineNum":"  822","line":"        let data = \"Hello World!\".as_bytes().to_base32();"},
{"lineNum":"  823","line":""},
{"lineNum":"  824","line":"        let mut written_str = String::new();"},
{"lineNum":"  825","line":"        {"},
{"lineNum":"  826","line":"            let mut writer = Bech32Writer::new(hrp, &mut written_str).unwrap();"},
{"lineNum":"  827","line":"            writer.write(&data).unwrap();"},
{"lineNum":"  828","line":"            writer.finalize().unwrap();"},
{"lineNum":"  829","line":"        }"},
{"lineNum":"  830","line":""},
{"lineNum":"  831","line":"        let encoded_str = encode(hrp, data).unwrap();"},
{"lineNum":"  832","line":""},
{"lineNum":"  833","line":"        assert_eq!(encoded_str, written_str);"},
{"lineNum":"  834","line":"    }"},
{"lineNum":"  835","line":""},
{"lineNum":"  836","line":"    #[test]"},
{"lineNum":"  837","line":"    fn write_on_drop() {"},
{"lineNum":"  838","line":"        let hrp = \"lntb\";"},
{"lineNum":"  839","line":"        let data = \"Hello World!\".as_bytes().to_base32();"},
{"lineNum":"  840","line":""},
{"lineNum":"  841","line":"        let mut written_str = String::new();"},
{"lineNum":"  842","line":"        {"},
{"lineNum":"  843","line":"            let mut writer = Bech32Writer::new(hrp, &mut written_str).unwrap();"},
{"lineNum":"  844","line":"            writer.write(&data).unwrap();"},
{"lineNum":"  845","line":"        }"},
{"lineNum":"  846","line":""},
{"lineNum":"  847","line":"        let encoded_str = encode(hrp, data).unwrap();"},
{"lineNum":"  848","line":""},
{"lineNum":"  849","line":"        assert_eq!(encoded_str, written_str);"},
{"lineNum":"  850","line":"    }"},
{"lineNum":"  851","line":""},
{"lineNum":"  852","line":"    #[test]"},
{"lineNum":"  853","line":"    fn test_hrp_case() {"},
{"lineNum":"  854","line":"        // Tests for issue with HRP case checking being ignored for encoding"},
{"lineNum":"  855","line":"        use ToBase32;"},
{"lineNum":"  856","line":"        let encoded_str = encode(\"HRP\", [0x00, 0x00].to_base32()).unwrap();"},
{"lineNum":"  857","line":""},
{"lineNum":"  858","line":"        assert_eq!(encoded_str, \"hrp1qqqq40atq3\");"},
{"lineNum":"  859","line":"    }"},
{"lineNum":"  860","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "lightning_invoice-3332d6d4aab2c25c", "date" : "2020-05-23 13:12:48", "instrumented" : 167, "covered" : 140,};
var merged_data = [];
