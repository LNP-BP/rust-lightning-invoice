var data = {lines:[
{"lineNum":"    1","line":"// Bitcoin secp256k1 bindings"},
{"lineNum":"    2","line":"// Written in 2014 by"},
{"lineNum":"    3","line":"//   Dawid CiÄ™Å¼arkiewicz"},
{"lineNum":"    4","line":"//   Andrew Poelstra"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// To the extent possible under law, the author(s) have dedicated all"},
{"lineNum":"    7","line":"// copyright and related and neighboring rights to this software to"},
{"lineNum":"    8","line":"// the public domain worldwide. This software is distributed without"},
{"lineNum":"    9","line":"// any warranty."},
{"lineNum":"   10","line":"//"},
{"lineNum":"   11","line":"// You should have received a copy of the CC0 Public Domain Dedication"},
{"lineNum":"   12","line":"// along with this software."},
{"lineNum":"   13","line":"// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>."},
{"lineNum":"   14","line":"//"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"//! # Public and secret keys"},
{"lineNum":"   17","line":""},
{"lineNum":"   18","line":"#[cfg(any(test, feature = \"rand\"))] use rand::Rng;"},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"use core::{fmt, str};"},
{"lineNum":"   21","line":""},
{"lineNum":"   22","line":"use super::{from_hex, Secp256k1};"},
{"lineNum":"   23","line":"use super::Error::{self, InvalidPublicKey, InvalidSecretKey};"},
{"lineNum":"   24","line":"use Signing;"},
{"lineNum":"   25","line":"use Verification;"},
{"lineNum":"   26","line":"use constants;"},
{"lineNum":"   27","line":"use ffi::{self, CPtr};"},
{"lineNum":"   28","line":""},
{"lineNum":"   29","line":"/// Secret 256-bit key used as `x` in an ECDSA signature"},
{"lineNum":"   30","line":"pub struct SecretKey([u8; constants::SECRET_KEY_SIZE]);"},
{"lineNum":"   31","line":"impl_array_newtype!(SecretKey, u8, constants::SECRET_KEY_SIZE);"},
{"lineNum":"   32","line":"impl_pretty_debug!(SecretKey);"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"impl fmt::LowerHex for SecretKey {"},
{"lineNum":"   35","line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"   36","line":"        for ch in &self.0[..] {"},
{"lineNum":"   37","line":"            write!(f, \"{:02x}\", *ch)?;"},
{"lineNum":"   38","line":"        }"},
{"lineNum":"   39","line":"        Ok(())"},
{"lineNum":"   40","line":"    }"},
{"lineNum":"   41","line":"}"},
{"lineNum":"   42","line":""},
{"lineNum":"   43","line":"impl fmt::Display for SecretKey {"},
{"lineNum":"   44","line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"   45","line":"        fmt::LowerHex::fmt(self, f)"},
{"lineNum":"   46","line":"    }"},
{"lineNum":"   47","line":"}"},
{"lineNum":"   48","line":""},
{"lineNum":"   49","line":"impl str::FromStr for SecretKey {"},
{"lineNum":"   50","line":"    type Err = Error;"},
{"lineNum":"   51","line":"    fn from_str(s: &str) -> Result<SecretKey, Error> {"},
{"lineNum":"   52","line":"        let mut res = [0; constants::SECRET_KEY_SIZE];"},
{"lineNum":"   53","line":"        match from_hex(s, &mut res) {"},
{"lineNum":"   54","line":"            Ok(constants::SECRET_KEY_SIZE) => Ok(SecretKey(res)),"},
{"lineNum":"   55","line":"            _ => Err(Error::InvalidSecretKey)"},
{"lineNum":"   56","line":"        }"},
{"lineNum":"   57","line":"    }"},
{"lineNum":"   58","line":"}"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"/// The number 1 encoded as a secret key"},
{"lineNum":"   61","line":"pub const ONE_KEY: SecretKey = SecretKey([0, 0, 0, 0, 0, 0, 0, 0,"},
{"lineNum":"   62","line":"                                          0, 0, 0, 0, 0, 0, 0, 0,"},
{"lineNum":"   63","line":"                                          0, 0, 0, 0, 0, 0, 0, 0,"},
{"lineNum":"   64","line":"                                          0, 0, 0, 0, 0, 0, 0, 1]);"},
{"lineNum":"   65","line":""},
{"lineNum":"   66","line":"/// A Secp256k1 public key, used for verification of signatures"},
{"lineNum":"   67","line":"#[derive(Copy, Clone, PartialEq, Eq, Debug, PartialOrd, Ord, Hash)]","class":"lineNoCov","hits":"0","possible_hits":"6",},
{"lineNum":"   68","line":"pub struct PublicKey(ffi::PublicKey);","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"impl fmt::LowerHex for PublicKey {"},
{"lineNum":"   71","line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"   72","line":"        let ser = self.serialize();"},
{"lineNum":"   73","line":"        for ch in &ser[..] {"},
{"lineNum":"   74","line":"            write!(f, \"{:02x}\", *ch)?;"},
{"lineNum":"   75","line":"        }"},
{"lineNum":"   76","line":"        Ok(())"},
{"lineNum":"   77","line":"    }"},
{"lineNum":"   78","line":"}"},
{"lineNum":"   79","line":""},
{"lineNum":"   80","line":"impl fmt::Display for PublicKey {"},
{"lineNum":"   81","line":"    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"   82","line":"        fmt::LowerHex::fmt(self, f)"},
{"lineNum":"   83","line":"    }"},
{"lineNum":"   84","line":"}"},
{"lineNum":"   85","line":""},
{"lineNum":"   86","line":"impl str::FromStr for PublicKey {"},
{"lineNum":"   87","line":"    type Err = Error;"},
{"lineNum":"   88","line":"    fn from_str(s: &str) -> Result<PublicKey, Error> {"},
{"lineNum":"   89","line":"        let mut res = [0; constants::UNCOMPRESSED_PUBLIC_KEY_SIZE];"},
{"lineNum":"   90","line":"        match from_hex(s, &mut res) {"},
{"lineNum":"   91","line":"            Ok(constants::PUBLIC_KEY_SIZE) => {"},
{"lineNum":"   92","line":"                PublicKey::from_slice("},
{"lineNum":"   93","line":"                    &res[0..constants::PUBLIC_KEY_SIZE]"},
{"lineNum":"   94","line":"                )"},
{"lineNum":"   95","line":"            }"},
{"lineNum":"   96","line":"            Ok(constants::UNCOMPRESSED_PUBLIC_KEY_SIZE) => {"},
{"lineNum":"   97","line":"                PublicKey::from_slice(&res)"},
{"lineNum":"   98","line":"            }"},
{"lineNum":"   99","line":"            _ => Err(Error::InvalidPublicKey)"},
{"lineNum":"  100","line":"        }"},
{"lineNum":"  101","line":"    }"},
{"lineNum":"  102","line":"}"},
{"lineNum":"  103","line":""},
{"lineNum":"  104","line":"#[cfg(any(test, feature = \"rand\"))]"},
{"lineNum":"  105","line":"fn random_32_bytes<R: Rng + ?Sized>(rng: &mut R) -> [u8; 32] {"},
{"lineNum":"  106","line":"    let mut ret = [0u8; 32];"},
{"lineNum":"  107","line":"    rng.fill_bytes(&mut ret);"},
{"lineNum":"  108","line":"    ret"},
{"lineNum":"  109","line":"}"},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"impl SecretKey {"},
{"lineNum":"  112","line":"    /// Creates a new random secret key. Requires compilation with the \"rand\" feature."},
{"lineNum":"  113","line":"    #[inline]"},
{"lineNum":"  114","line":"    #[cfg(any(test, feature = \"rand\"))]"},
{"lineNum":"  115","line":"    pub fn new<R: Rng + ?Sized>(rng: &mut R) -> SecretKey {"},
{"lineNum":"  116","line":"        let mut data = random_32_bytes(rng);"},
{"lineNum":"  117","line":"        unsafe {"},
{"lineNum":"  118","line":"            while ffi::secp256k1_ec_seckey_verify("},
{"lineNum":"  119","line":"                ffi::secp256k1_context_no_precomp,"},
{"lineNum":"  120","line":"                data.as_c_ptr(),"},
{"lineNum":"  121","line":"            ) == 0"},
{"lineNum":"  122","line":"            {"},
{"lineNum":"  123","line":"                data = random_32_bytes(rng);"},
{"lineNum":"  124","line":"            }"},
{"lineNum":"  125","line":"        }"},
{"lineNum":"  126","line":"        SecretKey(data)"},
{"lineNum":"  127","line":"    }"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    /// Converts a `SECRET_KEY_SIZE`-byte slice to a secret key"},
{"lineNum":"  130","line":"    #[inline]"},
{"lineNum":"  131","line":"    pub fn from_slice(data: &[u8])-> Result<SecretKey, Error> {"},
{"lineNum":"  132","line":"        match data.len() {"},
{"lineNum":"  133","line":"            constants::SECRET_KEY_SIZE => {"},
{"lineNum":"  134","line":"                let mut ret = [0; constants::SECRET_KEY_SIZE];"},
{"lineNum":"  135","line":"                unsafe {"},
{"lineNum":"  136","line":"                    if ffi::secp256k1_ec_seckey_verify("},
{"lineNum":"  137","line":"                        ffi::secp256k1_context_no_precomp,"},
{"lineNum":"  138","line":"                        data.as_c_ptr(),"},
{"lineNum":"  139","line":"                    ) == 0"},
{"lineNum":"  140","line":"                    {"},
{"lineNum":"  141","line":"                        return Err(InvalidSecretKey);"},
{"lineNum":"  142","line":"                    }"},
{"lineNum":"  143","line":"                }"},
{"lineNum":"  144","line":"                ret[..].copy_from_slice(data);"},
{"lineNum":"  145","line":"                Ok(SecretKey(ret))"},
{"lineNum":"  146","line":"            }"},
{"lineNum":"  147","line":"            _ => Err(InvalidSecretKey)"},
{"lineNum":"  148","line":"        }"},
{"lineNum":"  149","line":"    }"},
{"lineNum":"  150","line":""},
{"lineNum":"  151","line":"    #[inline]"},
{"lineNum":"  152","line":"    /// Adds one secret key to another, modulo the curve order. WIll"},
{"lineNum":"  153","line":"    /// return an error if the resulting key would be invalid or if"},
{"lineNum":"  154","line":"    /// the tweak was not a 32-byte length slice."},
{"lineNum":"  155","line":"    pub fn add_assign("},
{"lineNum":"  156","line":"        &mut self,"},
{"lineNum":"  157","line":"        other: &[u8],"},
{"lineNum":"  158","line":"    ) -> Result<(), Error> {"},
{"lineNum":"  159","line":"        if other.len() != 32 {"},
{"lineNum":"  160","line":"            return Err(Error::InvalidTweak);"},
{"lineNum":"  161","line":"        }"},
{"lineNum":"  162","line":"        unsafe {"},
{"lineNum":"  163","line":"            if ffi::secp256k1_ec_privkey_tweak_add("},
{"lineNum":"  164","line":"                ffi::secp256k1_context_no_precomp,"},
{"lineNum":"  165","line":"                self.as_mut_c_ptr(),"},
{"lineNum":"  166","line":"                other.as_c_ptr(),"},
{"lineNum":"  167","line":"            ) != 1"},
{"lineNum":"  168","line":"            {"},
{"lineNum":"  169","line":"                Err(Error::InvalidTweak)"},
{"lineNum":"  170","line":"            } else {"},
{"lineNum":"  171","line":"                Ok(())"},
{"lineNum":"  172","line":"            }"},
{"lineNum":"  173","line":"        }"},
{"lineNum":"  174","line":"    }"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    #[inline]"},
{"lineNum":"  177","line":"    /// Multiplies one secret key by another, modulo the curve order. Will"},
{"lineNum":"  178","line":"    /// return an error if the resulting key would be invalid or if"},
{"lineNum":"  179","line":"    /// the tweak was not a 32-byte length slice."},
{"lineNum":"  180","line":"    pub fn mul_assign("},
{"lineNum":"  181","line":"        &mut self,"},
{"lineNum":"  182","line":"        other: &[u8],"},
{"lineNum":"  183","line":"    ) -> Result<(), Error> {"},
{"lineNum":"  184","line":"        if other.len() != 32 {"},
{"lineNum":"  185","line":"            return Err(Error::InvalidTweak);"},
{"lineNum":"  186","line":"        }"},
{"lineNum":"  187","line":"        unsafe {"},
{"lineNum":"  188","line":"            if ffi::secp256k1_ec_privkey_tweak_mul("},
{"lineNum":"  189","line":"                ffi::secp256k1_context_no_precomp,"},
{"lineNum":"  190","line":"                self.as_mut_c_ptr(),"},
{"lineNum":"  191","line":"                other.as_c_ptr(),"},
{"lineNum":"  192","line":"            ) != 1"},
{"lineNum":"  193","line":"            {"},
{"lineNum":"  194","line":"                Err(Error::InvalidTweak)"},
{"lineNum":"  195","line":"            } else {"},
{"lineNum":"  196","line":"                Ok(())"},
{"lineNum":"  197","line":"            }"},
{"lineNum":"  198","line":"        }"},
{"lineNum":"  199","line":"    }"},
{"lineNum":"  200","line":"}"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"serde_impl!(SecretKey, constants::SECRET_KEY_SIZE);"},
{"lineNum":"  203","line":""},
{"lineNum":"  204","line":"impl PublicKey {"},
{"lineNum":"  205","line":"    /// Obtains a raw const pointer suitable for use with FFI functions"},
{"lineNum":"  206","line":"    #[inline]"},
{"lineNum":"  207","line":"    pub fn as_ptr(&self) -> *const ffi::PublicKey {","class":"lineCov","hits":"1","order":"5451","possible_hits":"1",},
{"lineNum":"  208","line":"        &self.0 as *const _"},
{"lineNum":"  209","line":"    }","class":"linePartCov","hits":"1","order":"5452","possible_hits":"2",},
{"lineNum":"  210","line":""},
{"lineNum":"  211","line":"    /// Obtains a raw mutable pointer suitable for use with FFI functions"},
{"lineNum":"  212","line":"    #[inline]"},
{"lineNum":"  213","line":"    pub fn as_mut_ptr(&mut self) -> *mut ffi::PublicKey {"},
{"lineNum":"  214","line":"        &mut self.0 as *mut _"},
{"lineNum":"  215","line":"    }"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"    /// Creates a new public key from a secret key."},
{"lineNum":"  218","line":"    #[inline]"},
{"lineNum":"  219","line":"    pub fn from_secret_key<C: Signing>(secp: &Secp256k1<C>,"},
{"lineNum":"  220","line":"                           sk: &SecretKey)"},
{"lineNum":"  221","line":"                           -> PublicKey {"},
{"lineNum":"  222","line":"        let mut pk = ffi::PublicKey::new();"},
{"lineNum":"  223","line":"        unsafe {"},
{"lineNum":"  224","line":"            // We can assume the return value because it\'s not possible to construct"},
{"lineNum":"  225","line":"            // an invalid `SecretKey` without transmute trickery or something"},
{"lineNum":"  226","line":"            let res = ffi::secp256k1_ec_pubkey_create(secp.ctx, &mut pk, sk.as_c_ptr());"},
{"lineNum":"  227","line":"            debug_assert_eq!(res, 1);"},
{"lineNum":"  228","line":"        }"},
{"lineNum":"  229","line":"        PublicKey(pk)"},
{"lineNum":"  230","line":"    }"},
{"lineNum":"  231","line":""},
{"lineNum":"  232","line":"    /// Creates a public key directly from a slice"},
{"lineNum":"  233","line":"    #[inline]"},
{"lineNum":"  234","line":"    pub fn from_slice(data: &[u8]) -> Result<PublicKey, Error> {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  235","line":"        if data.is_empty() {return Err(Error::InvalidPublicKey);}","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  236","line":""},
{"lineNum":"  237","line":"        let mut pk = ffi::PublicKey::new();","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  238","line":"        unsafe {"},
{"lineNum":"  239","line":"            if ffi::secp256k1_ec_pubkey_parse(","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  240","line":"                ffi::secp256k1_context_no_precomp,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  241","line":"                &mut pk,"},
{"lineNum":"  242","line":"                data.as_c_ptr(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  243","line":"                data.len() as usize,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  244","line":"            ) == 1"},
{"lineNum":"  245","line":"            {"},
{"lineNum":"  246","line":"                Ok(PublicKey(pk))","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  247","line":"            } else {"},
{"lineNum":"  248","line":"                Err(InvalidPublicKey)","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  249","line":"            }"},
{"lineNum":"  250","line":"        }"},
{"lineNum":"  251","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"3",},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"    #[inline]"},
{"lineNum":"  254","line":"    /// Serialize the key as a byte-encoded pair of values. In compressed form"},
{"lineNum":"  255","line":"    /// the y-coordinate is represented by only a single bit, as x determines"},
{"lineNum":"  256","line":"    /// it up to one bit."},
{"lineNum":"  257","line":"    pub fn serialize(&self) -> [u8; constants::PUBLIC_KEY_SIZE] {","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  258","line":"        let mut ret = [0; constants::PUBLIC_KEY_SIZE];","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  259","line":""},
{"lineNum":"  260","line":"        unsafe {"},
{"lineNum":"  261","line":"            let mut ret_len = constants::PUBLIC_KEY_SIZE as usize;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  262","line":"            let err = ffi::secp256k1_ec_pubkey_serialize(","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  263","line":"                ffi::secp256k1_context_no_precomp,","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  264","line":"                ret.as_mut_c_ptr(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  265","line":"                &mut ret_len,"},
{"lineNum":"  266","line":"                self.as_c_ptr(),","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  267","line":"                ffi::SECP256K1_SER_COMPRESSED,"},
{"lineNum":"  268","line":"            );"},
{"lineNum":"  269","line":"            debug_assert_eq!(err, 1);"},
{"lineNum":"  270","line":"            debug_assert_eq!(ret_len, ret.len());","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  271","line":"        }"},
{"lineNum":"  272","line":"        ret","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  273","line":"    }","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  274","line":""},
{"lineNum":"  275","line":"    /// Serialize the key as a byte-encoded pair of values, in uncompressed form"},
{"lineNum":"  276","line":"    pub fn serialize_uncompressed(&self) -> [u8; constants::UNCOMPRESSED_PUBLIC_KEY_SIZE] {"},
{"lineNum":"  277","line":"        let mut ret = [0; constants::UNCOMPRESSED_PUBLIC_KEY_SIZE];"},
{"lineNum":"  278","line":""},
{"lineNum":"  279","line":"        unsafe {"},
{"lineNum":"  280","line":"            let mut ret_len = constants::UNCOMPRESSED_PUBLIC_KEY_SIZE as usize;"},
{"lineNum":"  281","line":"            let err = ffi::secp256k1_ec_pubkey_serialize("},
{"lineNum":"  282","line":"                ffi::secp256k1_context_no_precomp,"},
{"lineNum":"  283","line":"                ret.as_mut_c_ptr(),"},
{"lineNum":"  284","line":"                &mut ret_len,"},
{"lineNum":"  285","line":"                self.as_c_ptr(),"},
{"lineNum":"  286","line":"                ffi::SECP256K1_SER_UNCOMPRESSED,"},
{"lineNum":"  287","line":"            );"},
{"lineNum":"  288","line":"            debug_assert_eq!(err, 1);"},
{"lineNum":"  289","line":"            debug_assert_eq!(ret_len, ret.len());"},
{"lineNum":"  290","line":"        }"},
{"lineNum":"  291","line":"        ret"},
{"lineNum":"  292","line":"    }"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"    #[inline]"},
{"lineNum":"  295","line":"    /// Adds the pk corresponding to `other` to the pk `self` in place"},
{"lineNum":"  296","line":"    /// Will return an error if the resulting key would be invalid or"},
{"lineNum":"  297","line":"    /// if the tweak was not a 32-byte length slice."},
{"lineNum":"  298","line":"    pub fn add_exp_assign<C: Verification>("},
{"lineNum":"  299","line":"        &mut self,"},
{"lineNum":"  300","line":"        secp: &Secp256k1<C>,"},
{"lineNum":"  301","line":"        other: &[u8]"},
{"lineNum":"  302","line":"    ) -> Result<(), Error> {"},
{"lineNum":"  303","line":"        if other.len() != 32 {"},
{"lineNum":"  304","line":"            return Err(Error::InvalidTweak);"},
{"lineNum":"  305","line":"        }"},
{"lineNum":"  306","line":"        unsafe {"},
{"lineNum":"  307","line":"            if ffi::secp256k1_ec_pubkey_tweak_add(secp.ctx, &mut self.0 as *mut _,"},
{"lineNum":"  308","line":"                                                  other.as_c_ptr()) == 1 {"},
{"lineNum":"  309","line":"                Ok(())"},
{"lineNum":"  310","line":"            } else {"},
{"lineNum":"  311","line":"                Err(Error::InvalidTweak)"},
{"lineNum":"  312","line":"            }"},
{"lineNum":"  313","line":"        }"},
{"lineNum":"  314","line":"    }"},
{"lineNum":"  315","line":""},
{"lineNum":"  316","line":"    #[inline]"},
{"lineNum":"  317","line":"    /// Muliplies the pk `self` in place by the scalar `other`"},
{"lineNum":"  318","line":"    /// Will return an error if the resulting key would be invalid or"},
{"lineNum":"  319","line":"    /// if the tweak was not a 32-byte length slice."},
{"lineNum":"  320","line":"    pub fn mul_assign<C: Verification>("},
{"lineNum":"  321","line":"        &mut self,"},
{"lineNum":"  322","line":"        secp: &Secp256k1<C>,"},
{"lineNum":"  323","line":"        other: &[u8],"},
{"lineNum":"  324","line":"    ) -> Result<(), Error> {"},
{"lineNum":"  325","line":"        if other.len() != 32 {"},
{"lineNum":"  326","line":"            return Err(Error::InvalidTweak);"},
{"lineNum":"  327","line":"        }"},
{"lineNum":"  328","line":"        unsafe {"},
{"lineNum":"  329","line":"            if ffi::secp256k1_ec_pubkey_tweak_mul(secp.ctx, &mut self.0 as *mut _,"},
{"lineNum":"  330","line":"                                                  other.as_c_ptr()) == 1 {"},
{"lineNum":"  331","line":"                Ok(())"},
{"lineNum":"  332","line":"            } else {"},
{"lineNum":"  333","line":"                Err(Error::InvalidTweak)"},
{"lineNum":"  334","line":"            }"},
{"lineNum":"  335","line":"        }"},
{"lineNum":"  336","line":"    }"},
{"lineNum":"  337","line":""},
{"lineNum":"  338","line":"    /// Adds a second key to this one, returning the sum. Returns an error if"},
{"lineNum":"  339","line":"    /// the result would be the point at infinity, i.e. we are adding this point"},
{"lineNum":"  340","line":"    /// to its own negation"},
{"lineNum":"  341","line":"    pub fn combine(&self, other: &PublicKey) -> Result<PublicKey, Error> {"},
{"lineNum":"  342","line":"        unsafe {"},
{"lineNum":"  343","line":"            let mut ret = ffi::PublicKey::new();"},
{"lineNum":"  344","line":"            let ptrs = [self.as_c_ptr(), other.as_c_ptr()];"},
{"lineNum":"  345","line":"            if ffi::secp256k1_ec_pubkey_combine("},
{"lineNum":"  346","line":"                ffi::secp256k1_context_no_precomp,"},
{"lineNum":"  347","line":"                &mut ret,"},
{"lineNum":"  348","line":"                ptrs.as_c_ptr(),"},
{"lineNum":"  349","line":"                2"},
{"lineNum":"  350","line":"            ) == 1"},
{"lineNum":"  351","line":"            {"},
{"lineNum":"  352","line":"                Ok(PublicKey(ret))"},
{"lineNum":"  353","line":"            } else {"},
{"lineNum":"  354","line":"                Err(InvalidPublicKey)"},
{"lineNum":"  355","line":"            }"},
{"lineNum":"  356","line":"        }"},
{"lineNum":"  357","line":"    }"},
{"lineNum":"  358","line":"}"},
{"lineNum":"  359","line":""},
{"lineNum":"  360","line":"impl CPtr for PublicKey {"},
{"lineNum":"  361","line":"    type Target = ffi::PublicKey;"},
{"lineNum":"  362","line":"    fn as_c_ptr(&self) -> *const Self::Target {","class":"lineCov","hits":"1","order":"5449","possible_hits":"1",},
{"lineNum":"  363","line":"        self.as_ptr()","class":"lineCov","hits":"1","order":"5450","possible_hits":"1",},
{"lineNum":"  364","line":"    }","class":"linePartCov","hits":"1","order":"5453","possible_hits":"2",},
{"lineNum":"  365","line":""},
{"lineNum":"  366","line":"    fn as_mut_c_ptr(&mut self) -> *mut Self::Target {"},
{"lineNum":"  367","line":"        self.as_mut_ptr()"},
{"lineNum":"  368","line":"    }"},
{"lineNum":"  369","line":"}"},
{"lineNum":"  370","line":""},
{"lineNum":"  371","line":""},
{"lineNum":"  372","line":"/// Creates a new public key from a FFI public key"},
{"lineNum":"  373","line":"impl From<ffi::PublicKey> for PublicKey {"},
{"lineNum":"  374","line":"    #[inline]"},
{"lineNum":"  375","line":"    fn from(pk: ffi::PublicKey) -> PublicKey {","class":"lineCov","hits":"1","order":"5329","possible_hits":"1",},
{"lineNum":"  376","line":"        PublicKey(pk)","class":"lineCov","hits":"1","order":"5330","possible_hits":"1",},
{"lineNum":"  377","line":"    }","class":"linePartCov","hits":"1","order":"5331","possible_hits":"2",},
{"lineNum":"  378","line":"}"},
{"lineNum":"  379","line":""},
{"lineNum":"  380","line":"#[cfg(feature = \"serde\")]"},
{"lineNum":"  381","line":"impl ::serde::Serialize for PublicKey {"},
{"lineNum":"  382","line":"    fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {"},
{"lineNum":"  383","line":"        if s.is_human_readable() {"},
{"lineNum":"  384","line":"            s.collect_str(self)"},
{"lineNum":"  385","line":"        } else {"},
{"lineNum":"  386","line":"            s.serialize_bytes(&self.serialize())"},
{"lineNum":"  387","line":"        }"},
{"lineNum":"  388","line":"    }"},
{"lineNum":"  389","line":"}"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"#[cfg(feature = \"serde\")]"},
{"lineNum":"  392","line":"impl<\'de> ::serde::Deserialize<\'de> for PublicKey {"},
{"lineNum":"  393","line":"    fn deserialize<D: ::serde::Deserializer<\'de>>(d: D) -> Result<PublicKey, D::Error> {"},
{"lineNum":"  394","line":"        if d.is_human_readable() {"},
{"lineNum":"  395","line":"            struct HexVisitor;"},
{"lineNum":"  396","line":""},
{"lineNum":"  397","line":"            impl<\'de> ::serde::de::Visitor<\'de> for HexVisitor {"},
{"lineNum":"  398","line":"                type Value = PublicKey;"},
{"lineNum":"  399","line":""},
{"lineNum":"  400","line":"                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  401","line":"                    formatter.write_str(\"an ASCII hex string\")"},
{"lineNum":"  402","line":"                }"},
{"lineNum":"  403","line":""},
{"lineNum":"  404","line":"                fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>"},
{"lineNum":"  405","line":"                where"},
{"lineNum":"  406","line":"                    E: ::serde::de::Error,"},
{"lineNum":"  407","line":"                {"},
{"lineNum":"  408","line":"                    if let Ok(hex) = str::from_utf8(v) {"},
{"lineNum":"  409","line":"                        str::FromStr::from_str(hex).map_err(E::custom)"},
{"lineNum":"  410","line":"                    } else {"},
{"lineNum":"  411","line":"                        Err(E::invalid_value(::serde::de::Unexpected::Bytes(v), &self))"},
{"lineNum":"  412","line":"                    }"},
{"lineNum":"  413","line":"                }"},
{"lineNum":"  414","line":""},
{"lineNum":"  415","line":"                fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>"},
{"lineNum":"  416","line":"                where"},
{"lineNum":"  417","line":"                    E: ::serde::de::Error,"},
{"lineNum":"  418","line":"                {"},
{"lineNum":"  419","line":"                    str::FromStr::from_str(v).map_err(E::custom)"},
{"lineNum":"  420","line":"                }"},
{"lineNum":"  421","line":"            }"},
{"lineNum":"  422","line":"            d.deserialize_str(HexVisitor)"},
{"lineNum":"  423","line":"        } else {"},
{"lineNum":"  424","line":"            struct BytesVisitor;"},
{"lineNum":"  425","line":""},
{"lineNum":"  426","line":"            impl<\'de> ::serde::de::Visitor<\'de> for BytesVisitor {"},
{"lineNum":"  427","line":"                type Value = PublicKey;"},
{"lineNum":"  428","line":""},
{"lineNum":"  429","line":"                fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {"},
{"lineNum":"  430","line":"                    formatter.write_str(\"a bytestring\")"},
{"lineNum":"  431","line":"                }"},
{"lineNum":"  432","line":""},
{"lineNum":"  433","line":"                fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>"},
{"lineNum":"  434","line":"                where"},
{"lineNum":"  435","line":"                    E: ::serde::de::Error,"},
{"lineNum":"  436","line":"                {"},
{"lineNum":"  437","line":"                    PublicKey::from_slice(v).map_err(E::custom)"},
{"lineNum":"  438","line":"                }"},
{"lineNum":"  439","line":"            }"},
{"lineNum":"  440","line":""},
{"lineNum":"  441","line":"            d.deserialize_bytes(BytesVisitor)"},
{"lineNum":"  442","line":"        }"},
{"lineNum":"  443","line":"    }"},
{"lineNum":"  444","line":"}"},
{"lineNum":"  445","line":""},
{"lineNum":"  446","line":"#[cfg(test)]"},
{"lineNum":"  447","line":"mod test {"},
{"lineNum":"  448","line":"    use Secp256k1;"},
{"lineNum":"  449","line":"    use from_hex;"},
{"lineNum":"  450","line":"    use super::super::Error::{InvalidPublicKey, InvalidSecretKey};"},
{"lineNum":"  451","line":"    use super::{PublicKey, SecretKey};"},
{"lineNum":"  452","line":"    use super::super::constants;"},
{"lineNum":"  453","line":""},
{"lineNum":"  454","line":"    use rand::{Error, ErrorKind, RngCore, thread_rng};"},
{"lineNum":"  455","line":"    use rand_core::impls;"},
{"lineNum":"  456","line":"    use std::iter;"},
{"lineNum":"  457","line":"    use std::str::FromStr;"},
{"lineNum":"  458","line":""},
{"lineNum":"  459","line":"    macro_rules! hex {"},
{"lineNum":"  460","line":"        ($hex:expr) => ({"},
{"lineNum":"  461","line":"            let mut result = vec![0; $hex.len() / 2];"},
{"lineNum":"  462","line":"            from_hex($hex, &mut result).expect(\"valid hex string\");"},
{"lineNum":"  463","line":"            result"},
{"lineNum":"  464","line":"        });"},
{"lineNum":"  465","line":"    }"},
{"lineNum":"  466","line":""},
{"lineNum":"  467","line":"    #[test]"},
{"lineNum":"  468","line":"    fn skey_from_slice() {"},
{"lineNum":"  469","line":"        let sk = SecretKey::from_slice(&[1; 31]);"},
{"lineNum":"  470","line":"        assert_eq!(sk, Err(InvalidSecretKey));"},
{"lineNum":"  471","line":""},
{"lineNum":"  472","line":"        let sk = SecretKey::from_slice(&[1; 32]);"},
{"lineNum":"  473","line":"        assert!(sk.is_ok());"},
{"lineNum":"  474","line":"    }"},
{"lineNum":"  475","line":""},
{"lineNum":"  476","line":"    #[test]"},
{"lineNum":"  477","line":"    fn pubkey_from_slice() {"},
{"lineNum":"  478","line":"        assert_eq!(PublicKey::from_slice(&[]), Err(InvalidPublicKey));"},
{"lineNum":"  479","line":"        assert_eq!(PublicKey::from_slice(&[1, 2, 3]), Err(InvalidPublicKey));"},
{"lineNum":"  480","line":""},
{"lineNum":"  481","line":"        let uncompressed = PublicKey::from_slice(&[4, 54, 57, 149, 239, 162, 148, 175, 246, 254, 239, 75, 154, 152, 10, 82, 234, 224, 85, 220, 40, 100, 57, 121, 30, 162, 94, 156, 135, 67, 74, 49, 179, 57, 236, 53, 162, 124, 149, 144, 168, 77, 74, 30, 72, 211, 229, 110, 111, 55, 96, 193, 86, 227, 183, 152, 195, 155, 51, 247, 123, 113, 60, 228, 188]);"},
{"lineNum":"  482","line":"        assert!(uncompressed.is_ok());"},
{"lineNum":"  483","line":""},
{"lineNum":"  484","line":"        let compressed = PublicKey::from_slice(&[3, 23, 183, 225, 206, 31, 159, 148, 195, 42, 67, 115, 146, 41, 248, 140, 11, 3, 51, 41, 111, 180, 110, 143, 114, 134, 88, 73, 198, 174, 52, 184, 78]);"},
{"lineNum":"  485","line":"        assert!(compressed.is_ok());"},
{"lineNum":"  486","line":"    }"},
{"lineNum":"  487","line":""},
{"lineNum":"  488","line":"    #[test]"},
{"lineNum":"  489","line":"    fn keypair_slice_round_trip() {"},
{"lineNum":"  490","line":"        let s = Secp256k1::new();"},
{"lineNum":"  491","line":""},
{"lineNum":"  492","line":"        let (sk1, pk1) = s.generate_keypair(&mut thread_rng());"},
{"lineNum":"  493","line":"        assert_eq!(SecretKey::from_slice(&sk1[..]), Ok(sk1));"},
{"lineNum":"  494","line":"        assert_eq!(PublicKey::from_slice(&pk1.serialize()[..]), Ok(pk1));"},
{"lineNum":"  495","line":"        assert_eq!(PublicKey::from_slice(&pk1.serialize_uncompressed()[..]), Ok(pk1));"},
{"lineNum":"  496","line":"    }"},
{"lineNum":"  497","line":""},
{"lineNum":"  498","line":"    #[test]"},
{"lineNum":"  499","line":"    fn invalid_secret_key() {"},
{"lineNum":"  500","line":"        // Zero"},
{"lineNum":"  501","line":"        assert_eq!(SecretKey::from_slice(&[0; 32]), Err(InvalidSecretKey));"},
{"lineNum":"  502","line":"        // -1"},
{"lineNum":"  503","line":"        assert_eq!(SecretKey::from_slice(&[0xff; 32]), Err(InvalidSecretKey));"},
{"lineNum":"  504","line":"        // Top of range"},
{"lineNum":"  505","line":"        assert!(SecretKey::from_slice(&["},
{"lineNum":"  506","line":"            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,"},
{"lineNum":"  507","line":"            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,"},
{"lineNum":"  508","line":"            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,"},
{"lineNum":"  509","line":"            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x40,"},
{"lineNum":"  510","line":"        ]).is_ok());"},
{"lineNum":"  511","line":"        // One past top of range"},
{"lineNum":"  512","line":"        assert!(SecretKey::from_slice(&["},
{"lineNum":"  513","line":"            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,"},
{"lineNum":"  514","line":"            0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,"},
{"lineNum":"  515","line":"            0xBA, 0xAE, 0xDC, 0xE6, 0xAF, 0x48, 0xA0, 0x3B,"},
{"lineNum":"  516","line":"            0xBF, 0xD2, 0x5E, 0x8C, 0xD0, 0x36, 0x41, 0x41,"},
{"lineNum":"  517","line":"        ]).is_err());"},
{"lineNum":"  518","line":"    }"},
{"lineNum":"  519","line":""},
{"lineNum":"  520","line":"    #[test]"},
{"lineNum":"  521","line":"    fn test_out_of_range() {"},
{"lineNum":"  522","line":""},
{"lineNum":"  523","line":"        struct BadRng(u8);"},
{"lineNum":"  524","line":"        impl RngCore for BadRng {"},
{"lineNum":"  525","line":"            fn next_u32(&mut self) -> u32 { unimplemented!() }"},
{"lineNum":"  526","line":"            fn next_u64(&mut self) -> u64 { unimplemented!() }"},
{"lineNum":"  527","line":"            // This will set a secret key to a little over the"},
{"lineNum":"  528","line":"            // group order, then decrement with repeated calls"},
{"lineNum":"  529","line":"            // until it returns a valid key"},
{"lineNum":"  530","line":"            fn fill_bytes(&mut self, data: &mut [u8]) {"},
{"lineNum":"  531","line":"                let group_order: [u8; 32] = ["},
{"lineNum":"  532","line":"                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,"},
{"lineNum":"  533","line":"                    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe,"},
{"lineNum":"  534","line":"                    0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b,"},
{"lineNum":"  535","line":"                    0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41];"},
{"lineNum":"  536","line":"                assert_eq!(data.len(), 32);"},
{"lineNum":"  537","line":"                data.copy_from_slice(&group_order[..]);"},
{"lineNum":"  538","line":"                data[31] = self.0;"},
{"lineNum":"  539","line":"                self.0 -= 1;"},
{"lineNum":"  540","line":"            }"},
{"lineNum":"  541","line":"            fn try_fill_bytes(&mut self, dest: &mut [u8]) -> Result<(), Error> {"},
{"lineNum":"  542","line":"                Ok(self.fill_bytes(dest))"},
{"lineNum":"  543","line":"            }"},
{"lineNum":"  544","line":"        }"},
{"lineNum":"  545","line":""},
{"lineNum":"  546","line":"        let s = Secp256k1::new();"},
{"lineNum":"  547","line":"        s.generate_keypair(&mut BadRng(0xff));"},
{"lineNum":"  548","line":"    }"},
{"lineNum":"  549","line":""},
{"lineNum":"  550","line":"    #[test]"},
{"lineNum":"  551","line":"    fn test_pubkey_from_bad_slice() {"},
{"lineNum":"  552","line":"        // Bad sizes"},
{"lineNum":"  553","line":"        assert_eq!("},
{"lineNum":"  554","line":"            PublicKey::from_slice(&[0; constants::PUBLIC_KEY_SIZE - 1]),"},
{"lineNum":"  555","line":"            Err(InvalidPublicKey)"},
{"lineNum":"  556","line":"        );"},
{"lineNum":"  557","line":"        assert_eq!("},
{"lineNum":"  558","line":"            PublicKey::from_slice(&[0; constants::PUBLIC_KEY_SIZE + 1]),"},
{"lineNum":"  559","line":"            Err(InvalidPublicKey)"},
{"lineNum":"  560","line":"        );"},
{"lineNum":"  561","line":"        assert_eq!("},
{"lineNum":"  562","line":"            PublicKey::from_slice(&[0; constants::UNCOMPRESSED_PUBLIC_KEY_SIZE - 1]),"},
{"lineNum":"  563","line":"            Err(InvalidPublicKey)"},
{"lineNum":"  564","line":"        );"},
{"lineNum":"  565","line":"        assert_eq!("},
{"lineNum":"  566","line":"            PublicKey::from_slice(&[0; constants::UNCOMPRESSED_PUBLIC_KEY_SIZE + 1]),"},
{"lineNum":"  567","line":"            Err(InvalidPublicKey)"},
{"lineNum":"  568","line":"        );"},
{"lineNum":"  569","line":""},
{"lineNum":"  570","line":"        // Bad parse"},
{"lineNum":"  571","line":"        assert_eq!("},
{"lineNum":"  572","line":"            PublicKey::from_slice(&[0xff; constants::UNCOMPRESSED_PUBLIC_KEY_SIZE]),"},
{"lineNum":"  573","line":"            Err(InvalidPublicKey)"},
{"lineNum":"  574","line":"        );"},
{"lineNum":"  575","line":"        assert_eq!("},
{"lineNum":"  576","line":"            PublicKey::from_slice(&[0x55; constants::PUBLIC_KEY_SIZE]),"},
{"lineNum":"  577","line":"            Err(InvalidPublicKey)"},
{"lineNum":"  578","line":"        );"},
{"lineNum":"  579","line":"        assert_eq!("},
{"lineNum":"  580","line":"            PublicKey::from_slice(&[]),"},
{"lineNum":"  581","line":"            Err(InvalidPublicKey)"},
{"lineNum":"  582","line":"        );"},
{"lineNum":"  583","line":"    }"},
{"lineNum":"  584","line":""},
{"lineNum":"  585","line":"    #[test]"},
{"lineNum":"  586","line":"    fn test_seckey_from_bad_slice() {"},
{"lineNum":"  587","line":"        // Bad sizes"},
{"lineNum":"  588","line":"        assert_eq!("},
{"lineNum":"  589","line":"            SecretKey::from_slice(&[0; constants::SECRET_KEY_SIZE - 1]),"},
{"lineNum":"  590","line":"            Err(InvalidSecretKey)"},
{"lineNum":"  591","line":"        );"},
{"lineNum":"  592","line":"        assert_eq!("},
{"lineNum":"  593","line":"            SecretKey::from_slice(&[0; constants::SECRET_KEY_SIZE + 1]),"},
{"lineNum":"  594","line":"            Err(InvalidSecretKey)"},
{"lineNum":"  595","line":"        );"},
{"lineNum":"  596","line":"        // Bad parse"},
{"lineNum":"  597","line":"        assert_eq!("},
{"lineNum":"  598","line":"            SecretKey::from_slice(&[0xff; constants::SECRET_KEY_SIZE]),"},
{"lineNum":"  599","line":"            Err(InvalidSecretKey)"},
{"lineNum":"  600","line":"        );"},
{"lineNum":"  601","line":"        assert_eq!("},
{"lineNum":"  602","line":"            SecretKey::from_slice(&[0x00; constants::SECRET_KEY_SIZE]),"},
{"lineNum":"  603","line":"            Err(InvalidSecretKey)"},
{"lineNum":"  604","line":"        );"},
{"lineNum":"  605","line":"        assert_eq!("},
{"lineNum":"  606","line":"            SecretKey::from_slice(&[]),"},
{"lineNum":"  607","line":"            Err(InvalidSecretKey)"},
{"lineNum":"  608","line":"        );"},
{"lineNum":"  609","line":"    }"},
{"lineNum":"  610","line":""},
{"lineNum":"  611","line":"    #[test]"},
{"lineNum":"  612","line":"    fn test_debug_output() {"},
{"lineNum":"  613","line":"        struct DumbRng(u32);"},
{"lineNum":"  614","line":"        impl RngCore for DumbRng {"},
{"lineNum":"  615","line":"            fn next_u32(&mut self) -> u32 {"},
{"lineNum":"  616","line":"                self.0 = self.0.wrapping_add(1);"},
{"lineNum":"  617","line":"                self.0"},
{"lineNum":"  618","line":"            }"},
{"lineNum":"  619","line":"            fn next_u64(&mut self) -> u64 {"},
{"lineNum":"  620","line":"                self.next_u32() as u64"},
{"lineNum":"  621","line":"            }"},
{"lineNum":"  622","line":"            fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> Result<(), Error> {"},
{"lineNum":"  623","line":"                Err(Error::new(ErrorKind::Unavailable, \"not implemented\"))"},
{"lineNum":"  624","line":"            }"},
{"lineNum":"  625","line":""},
{"lineNum":"  626","line":"            fn fill_bytes(&mut self, dest: &mut [u8]) {"},
{"lineNum":"  627","line":"                impls::fill_bytes_via_next(self, dest);"},
{"lineNum":"  628","line":"            }"},
{"lineNum":"  629","line":"        }"},
{"lineNum":"  630","line":""},
{"lineNum":"  631","line":"        let s = Secp256k1::new();"},
{"lineNum":"  632","line":"        let (sk, _) = s.generate_keypair(&mut DumbRng(0));"},
{"lineNum":"  633","line":""},
{"lineNum":"  634","line":"        assert_eq!(&format!(\"{:?}\", sk),"},
{"lineNum":"  635","line":"                   \"SecretKey(0100000000000000020000000000000003000000000000000400000000000000)\");"},
{"lineNum":"  636","line":"    }"},
{"lineNum":"  637","line":""},
{"lineNum":"  638","line":"    #[test]"},
{"lineNum":"  639","line":"    fn test_display_output() {"},
{"lineNum":"  640","line":"        static SK_BYTES: [u8; 32] = ["},
{"lineNum":"  641","line":"            0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,"},
{"lineNum":"  642","line":"            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,"},
{"lineNum":"  643","line":"            0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,"},
{"lineNum":"  644","line":"            0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63, 0x63,"},
{"lineNum":"  645","line":"        ];"},
{"lineNum":"  646","line":""},
{"lineNum":"  647","line":"        let s = Secp256k1::signing_only();"},
{"lineNum":"  648","line":"        let sk = SecretKey::from_slice(&SK_BYTES).expect(\"sk\");"},
{"lineNum":"  649","line":"        let pk = PublicKey::from_secret_key(&s, &sk);"},
{"lineNum":"  650","line":""},
{"lineNum":"  651","line":"        assert_eq!("},
{"lineNum":"  652","line":"            sk.to_string(),"},
{"lineNum":"  653","line":"            \"01010101010101010001020304050607ffff0000ffff00006363636363636363\""},
{"lineNum":"  654","line":"        );"},
{"lineNum":"  655","line":"        assert_eq!("},
{"lineNum":"  656","line":"            SecretKey::from_str(\"01010101010101010001020304050607ffff0000ffff00006363636363636363\").unwrap(),"},
{"lineNum":"  657","line":"            sk"},
{"lineNum":"  658","line":"        );"},
{"lineNum":"  659","line":"        assert_eq!("},
{"lineNum":"  660","line":"            pk.to_string(),"},
{"lineNum":"  661","line":"            \"0218845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd166\""},
{"lineNum":"  662","line":"        );"},
{"lineNum":"  663","line":"        assert_eq!("},
{"lineNum":"  664","line":"            PublicKey::from_str(\"0218845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd166\").unwrap(),"},
{"lineNum":"  665","line":"            pk"},
{"lineNum":"  666","line":"        );"},
{"lineNum":"  667","line":"        assert_eq!("},
{"lineNum":"  668","line":"            PublicKey::from_str(\"04\\"},
{"lineNum":"  669","line":"                18845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd166\\"},
{"lineNum":"  670","line":"                84B84DB303A340CD7D6823EE88174747D12A67D2F8F2F9BA40846EE5EE7A44F6\""},
{"lineNum":"  671","line":"            ).unwrap(),"},
{"lineNum":"  672","line":"            pk"},
{"lineNum":"  673","line":"        );"},
{"lineNum":"  674","line":""},
{"lineNum":"  675","line":"        assert!(SecretKey::from_str(\"fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\").is_err());"},
{"lineNum":"  676","line":"        assert!(SecretKey::from_str(\"01010101010101010001020304050607ffff0000ffff0000636363636363636363\").is_err());"},
{"lineNum":"  677","line":"        assert!(SecretKey::from_str(\"01010101010101010001020304050607ffff0000ffff0000636363636363636\").is_err());"},
{"lineNum":"  678","line":"        assert!(SecretKey::from_str(\"01010101010101010001020304050607ffff0000ffff000063636363636363\").is_err());"},
{"lineNum":"  679","line":"        assert!(SecretKey::from_str(\"01010101010101010001020304050607ffff0000ffff000063636363636363xx\").is_err());"},
{"lineNum":"  680","line":"        assert!(PublicKey::from_str(\"0300000000000000000000000000000000000000000000000000000000000000000\").is_err());"},
{"lineNum":"  681","line":"        assert!(PublicKey::from_str(\"0218845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd16601\").is_err());"},
{"lineNum":"  682","line":"        assert!(PublicKey::from_str(\"0218845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd16\").is_err());"},
{"lineNum":"  683","line":"        assert!(PublicKey::from_str(\"0218845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd1\").is_err());"},
{"lineNum":"  684","line":"        assert!(PublicKey::from_str(\"xx0218845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd1\").is_err());"},
{"lineNum":"  685","line":""},
{"lineNum":"  686","line":"        let long_str: String = iter::repeat(\'a\').take(1024 * 1024).collect();"},
{"lineNum":"  687","line":"        assert!(SecretKey::from_str(&long_str).is_err());"},
{"lineNum":"  688","line":"        assert!(PublicKey::from_str(&long_str).is_err());"},
{"lineNum":"  689","line":"    }"},
{"lineNum":"  690","line":""},
{"lineNum":"  691","line":"    #[test]"},
{"lineNum":"  692","line":"    fn test_pubkey_serialize() {"},
{"lineNum":"  693","line":"        struct DumbRng(u32);"},
{"lineNum":"  694","line":"        impl RngCore for DumbRng {"},
{"lineNum":"  695","line":"            fn next_u32(&mut self) -> u32 {"},
{"lineNum":"  696","line":"                self.0 = self.0.wrapping_add(1);"},
{"lineNum":"  697","line":"                self.0"},
{"lineNum":"  698","line":"            }"},
{"lineNum":"  699","line":"            fn next_u64(&mut self) -> u64 {"},
{"lineNum":"  700","line":"                self.next_u32() as u64"},
{"lineNum":"  701","line":"            }"},
{"lineNum":"  702","line":"            fn try_fill_bytes(&mut self, _dest: &mut [u8]) -> Result<(), Error> {"},
{"lineNum":"  703","line":"                Err(Error::new(ErrorKind::Unavailable, \"not implemented\"))"},
{"lineNum":"  704","line":"            }"},
{"lineNum":"  705","line":""},
{"lineNum":"  706","line":"            fn fill_bytes(&mut self, dest: &mut [u8]) {"},
{"lineNum":"  707","line":"                impls::fill_bytes_via_next(self, dest);"},
{"lineNum":"  708","line":"            }"},
{"lineNum":"  709","line":"        }"},
{"lineNum":"  710","line":""},
{"lineNum":"  711","line":"        let s = Secp256k1::new();"},
{"lineNum":"  712","line":"        let (_, pk1) = s.generate_keypair(&mut DumbRng(0));"},
{"lineNum":"  713","line":"        assert_eq!(&pk1.serialize_uncompressed()[..],"},
{"lineNum":"  714","line":"                   &[4, 124, 121, 49, 14, 253, 63, 197, 50, 39, 194, 107, 17, 193, 219, 108, 154, 126, 9, 181, 248, 2, 12, 149, 233, 198, 71, 149, 134, 250, 184, 154, 229, 185, 28, 165, 110, 27, 3, 162, 126, 238, 167, 157, 242, 221, 76, 251, 237, 34, 231, 72, 39, 245, 3, 191, 64, 111, 170, 117, 103, 82, 28, 102, 163][..]);"},
{"lineNum":"  715","line":"        assert_eq!(&pk1.serialize()[..],"},
{"lineNum":"  716","line":"                   &[3, 124, 121, 49, 14, 253, 63, 197, 50, 39, 194, 107, 17, 193, 219, 108, 154, 126, 9, 181, 248, 2, 12, 149, 233, 198, 71, 149, 134, 250, 184, 154, 229][..]);"},
{"lineNum":"  717","line":"    }"},
{"lineNum":"  718","line":""},
{"lineNum":"  719","line":"    #[test]"},
{"lineNum":"  720","line":"    fn test_addition() {"},
{"lineNum":"  721","line":"        let s = Secp256k1::new();"},
{"lineNum":"  722","line":""},
{"lineNum":"  723","line":"        let (mut sk1, mut pk1) = s.generate_keypair(&mut thread_rng());"},
{"lineNum":"  724","line":"        let (mut sk2, mut pk2) = s.generate_keypair(&mut thread_rng());"},
{"lineNum":"  725","line":""},
{"lineNum":"  726","line":"        assert_eq!(PublicKey::from_secret_key(&s, &sk1), pk1);"},
{"lineNum":"  727","line":"        assert!(sk1.add_assign(&sk2[..]).is_ok());"},
{"lineNum":"  728","line":"        assert!(pk1.add_exp_assign(&s, &sk2[..]).is_ok());"},
{"lineNum":"  729","line":"        assert_eq!(PublicKey::from_secret_key(&s, &sk1), pk1);"},
{"lineNum":"  730","line":""},
{"lineNum":"  731","line":"        assert_eq!(PublicKey::from_secret_key(&s, &sk2), pk2);"},
{"lineNum":"  732","line":"        assert!(sk2.add_assign(&sk1[..]).is_ok());"},
{"lineNum":"  733","line":"        assert!(pk2.add_exp_assign(&s, &sk1[..]).is_ok());"},
{"lineNum":"  734","line":"        assert_eq!(PublicKey::from_secret_key(&s, &sk2), pk2);"},
{"lineNum":"  735","line":"    }"},
{"lineNum":"  736","line":""},
{"lineNum":"  737","line":"    #[test]"},
{"lineNum":"  738","line":"    fn test_multiplication() {"},
{"lineNum":"  739","line":"        let s = Secp256k1::new();"},
{"lineNum":"  740","line":""},
{"lineNum":"  741","line":"        let (mut sk1, mut pk1) = s.generate_keypair(&mut thread_rng());"},
{"lineNum":"  742","line":"        let (mut sk2, mut pk2) = s.generate_keypair(&mut thread_rng());"},
{"lineNum":"  743","line":""},
{"lineNum":"  744","line":"        assert_eq!(PublicKey::from_secret_key(&s, &sk1), pk1);"},
{"lineNum":"  745","line":"        assert!(sk1.mul_assign(&sk2[..]).is_ok());"},
{"lineNum":"  746","line":"        assert!(pk1.mul_assign(&s, &sk2[..]).is_ok());"},
{"lineNum":"  747","line":"        assert_eq!(PublicKey::from_secret_key(&s, &sk1), pk1);"},
{"lineNum":"  748","line":""},
{"lineNum":"  749","line":"        assert_eq!(PublicKey::from_secret_key(&s, &sk2), pk2);"},
{"lineNum":"  750","line":"        assert!(sk2.mul_assign(&sk1[..]).is_ok());"},
{"lineNum":"  751","line":"        assert!(pk2.mul_assign(&s, &sk1[..]).is_ok());"},
{"lineNum":"  752","line":"        assert_eq!(PublicKey::from_secret_key(&s, &sk2), pk2);"},
{"lineNum":"  753","line":"    }"},
{"lineNum":"  754","line":""},
{"lineNum":"  755","line":"    #[test]"},
{"lineNum":"  756","line":"    fn pubkey_hash() {"},
{"lineNum":"  757","line":"        use std::collections::hash_map::DefaultHasher;"},
{"lineNum":"  758","line":"        use std::hash::{Hash, Hasher};"},
{"lineNum":"  759","line":"        use std::collections::HashSet;"},
{"lineNum":"  760","line":""},
{"lineNum":"  761","line":"        fn hash<T: Hash>(t: &T) -> u64 {"},
{"lineNum":"  762","line":"            let mut s = DefaultHasher::new();"},
{"lineNum":"  763","line":"            t.hash(&mut s);"},
{"lineNum":"  764","line":"            s.finish()"},
{"lineNum":"  765","line":"        }"},
{"lineNum":"  766","line":""},
{"lineNum":"  767","line":"        let s = Secp256k1::new();"},
{"lineNum":"  768","line":"        let mut set = HashSet::new();"},
{"lineNum":"  769","line":"        const COUNT : usize = 1024;"},
{"lineNum":"  770","line":"        let count = (0..COUNT).map(|_| {"},
{"lineNum":"  771","line":"            let (_, pk) = s.generate_keypair(&mut thread_rng());"},
{"lineNum":"  772","line":"            let hash = hash(&pk);"},
{"lineNum":"  773","line":"            assert!(!set.contains(&hash));"},
{"lineNum":"  774","line":"            set.insert(hash);"},
{"lineNum":"  775","line":"        }).count();"},
{"lineNum":"  776","line":"        assert_eq!(count, COUNT);"},
{"lineNum":"  777","line":"    }"},
{"lineNum":"  778","line":""},
{"lineNum":"  779","line":"    #[test]"},
{"lineNum":"  780","line":"    fn pubkey_combine() {"},
{"lineNum":"  781","line":"        let compressed1 = PublicKey::from_slice("},
{"lineNum":"  782","line":"            &hex!(\"0241cc121c419921942add6db6482fb36243faf83317c866d2a28d8c6d7089f7ba\"),"},
{"lineNum":"  783","line":"        ).unwrap();"},
{"lineNum":"  784","line":"        let compressed2 = PublicKey::from_slice("},
{"lineNum":"  785","line":"            &hex!(\"02e6642fd69bd211f93f7f1f36ca51a26a5290eb2dd1b0d8279a87bb0d480c8443\"),"},
{"lineNum":"  786","line":"        ).unwrap();"},
{"lineNum":"  787","line":"        let exp_sum = PublicKey::from_slice("},
{"lineNum":"  788","line":"            &hex!(\"0384526253c27c7aef56c7b71a5cd25bebb66dddda437826defc5b2568bde81f07\"),"},
{"lineNum":"  789","line":"        ).unwrap();"},
{"lineNum":"  790","line":""},
{"lineNum":"  791","line":"        let sum1 = compressed1.combine(&compressed2);"},
{"lineNum":"  792","line":"        assert!(sum1.is_ok());"},
{"lineNum":"  793","line":"        let sum2 = compressed2.combine(&compressed1);"},
{"lineNum":"  794","line":"        assert!(sum2.is_ok());"},
{"lineNum":"  795","line":"        assert_eq!(sum1, sum2);"},
{"lineNum":"  796","line":"        assert_eq!(sum1.unwrap(), exp_sum);"},
{"lineNum":"  797","line":"    }"},
{"lineNum":"  798","line":""},
{"lineNum":"  799","line":"    #[test]"},
{"lineNum":"  800","line":"    fn pubkey_equal() {"},
{"lineNum":"  801","line":"        let pk1 = PublicKey::from_slice("},
{"lineNum":"  802","line":"            &hex!(\"0241cc121c419921942add6db6482fb36243faf83317c866d2a28d8c6d7089f7ba\"),"},
{"lineNum":"  803","line":"        ).unwrap();"},
{"lineNum":"  804","line":"        let pk2 = pk1.clone();"},
{"lineNum":"  805","line":"        let pk3 = PublicKey::from_slice("},
{"lineNum":"  806","line":"            &hex!(\"02e6642fd69bd211f93f7f1f36ca51a26a5290eb2dd1b0d8279a87bb0d480c8443\"),"},
{"lineNum":"  807","line":"        ).unwrap();"},
{"lineNum":"  808","line":""},
{"lineNum":"  809","line":"        assert!(pk1 == pk2);"},
{"lineNum":"  810","line":"        assert!(pk1 <= pk2);"},
{"lineNum":"  811","line":"        assert!(pk2 <= pk1);"},
{"lineNum":"  812","line":"        assert!(!(pk2 < pk1));"},
{"lineNum":"  813","line":"        assert!(!(pk1 < pk2));"},
{"lineNum":"  814","line":""},
{"lineNum":"  815","line":"        assert!(pk3 < pk1);"},
{"lineNum":"  816","line":"        assert!(pk1 > pk3);"},
{"lineNum":"  817","line":"        assert!(pk3 <= pk1);"},
{"lineNum":"  818","line":"        assert!(pk1 >= pk3);"},
{"lineNum":"  819","line":"    }"},
{"lineNum":"  820","line":""},
{"lineNum":"  821","line":"    #[cfg(feature = \"serde\")]"},
{"lineNum":"  822","line":"    #[test]"},
{"lineNum":"  823","line":"    fn test_signature_serde() {"},
{"lineNum":"  824","line":"        use serde_test::{Configure, Token, assert_tokens};"},
{"lineNum":"  825","line":"        static SK_BYTES: [u8; 32] = ["},
{"lineNum":"  826","line":"            1, 1, 1, 1, 1, 1, 1, 1,"},
{"lineNum":"  827","line":"            0, 1, 2, 3, 4, 5, 6, 7,"},
{"lineNum":"  828","line":"            0xff, 0xff, 0, 0, 0xff, 0xff, 0, 0,"},
{"lineNum":"  829","line":"            99, 99, 99, 99, 99, 99, 99, 99"},
{"lineNum":"  830","line":"        ];"},
{"lineNum":"  831","line":"        static SK_STR: &\'static str = \"\\"},
{"lineNum":"  832","line":"            01010101010101010001020304050607ffff0000ffff00006363636363636363\\"},
{"lineNum":"  833","line":"        \";"},
{"lineNum":"  834","line":"        static PK_BYTES: [u8; 33] = ["},
{"lineNum":"  835","line":"            0x02,"},
{"lineNum":"  836","line":"            0x18, 0x84, 0x57, 0x81, 0xf6, 0x31, 0xc4, 0x8f,"},
{"lineNum":"  837","line":"            0x1c, 0x97, 0x09, 0xe2, 0x30, 0x92, 0x06, 0x7d,"},
{"lineNum":"  838","line":"            0x06, 0x83, 0x7f, 0x30, 0xaa, 0x0c, 0xd0, 0x54,"},
{"lineNum":"  839","line":"            0x4a, 0xc8, 0x87, 0xfe, 0x91, 0xdd, 0xd1, 0x66,"},
{"lineNum":"  840","line":"        ];"},
{"lineNum":"  841","line":"        static PK_STR: &\'static str = \"\\"},
{"lineNum":"  842","line":"            0218845781f631c48f1c9709e23092067d06837f30aa0cd0544ac887fe91ddd166\\"},
{"lineNum":"  843","line":"        \";"},
{"lineNum":"  844","line":""},
{"lineNum":"  845","line":"        let s = Secp256k1::new();"},
{"lineNum":"  846","line":""},
{"lineNum":"  847","line":"        let sk = SecretKey::from_slice(&SK_BYTES).unwrap();"},
{"lineNum":"  848","line":"        let pk = PublicKey::from_secret_key(&s, &sk);"},
{"lineNum":"  849","line":""},
{"lineNum":"  850","line":"        assert_tokens(&sk.compact(), &[Token::BorrowedBytes(&SK_BYTES[..])]);"},
{"lineNum":"  851","line":"        assert_tokens(&sk.readable(), &[Token::BorrowedStr(SK_STR)]);"},
{"lineNum":"  852","line":"        assert_tokens(&pk.compact(), &[Token::BorrowedBytes(&PK_BYTES[..])]);"},
{"lineNum":"  853","line":"        assert_tokens(&pk.readable(), &[Token::BorrowedStr(PK_STR)]);"},
{"lineNum":"  854","line":"    }"},
{"lineNum":"  855","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "ser_de-82e03ad9d566398b", "date" : "2020-05-23 13:12:49", "instrumented" : 30, "covered" : 8,};
var merged_data = [];
