var data = {lines:[
{"lineNum":"    1","line":"// Bitcoin secp256k1 bindings"},
{"lineNum":"    2","line":"// Written in 2014 by"},
{"lineNum":"    3","line":"//   Dawid Ciężarkiewicz"},
{"lineNum":"    4","line":"//   Andrew Poelstra"},
{"lineNum":"    5","line":"//"},
{"lineNum":"    6","line":"// To the extent possible under law, the author(s) have dedicated all"},
{"lineNum":"    7","line":"// copyright and related and neighboring rights to this software to"},
{"lineNum":"    8","line":"// the public domain worldwide. This software is distributed without"},
{"lineNum":"    9","line":"// any warranty."},
{"lineNum":"   10","line":"//"},
{"lineNum":"   11","line":"// You should have received a copy of the CC0 Public Domain Dedication"},
{"lineNum":"   12","line":"// along with this software."},
{"lineNum":"   13","line":"// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>."},
{"lineNum":"   14","line":"//"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"//! # Recovery module"},
{"lineNum":"   17","line":"//! Provides a signing function that allows recovering the public key from the"},
{"lineNum":"   18","line":"//! signature."},
{"lineNum":"   19","line":""},
{"lineNum":"   20","line":"use core::ptr;"},
{"lineNum":"   21","line":"use key;"},
{"lineNum":"   22","line":"use super::{Secp256k1, Message, Error, Signature, Verification, Signing};"},
{"lineNum":"   23","line":"use super::ffi as super_ffi;"},
{"lineNum":"   24","line":"pub use key::SecretKey;"},
{"lineNum":"   25","line":"pub use key::PublicKey;"},
{"lineNum":"   26","line":"use self::super_ffi::CPtr;"},
{"lineNum":"   27","line":""},
{"lineNum":"   28","line":"mod ffi;"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"/// A tag used for recovering the public key from a compact signature"},
{"lineNum":"   31","line":"#[derive(Copy, Clone, PartialEq, Eq, Debug)]"},
{"lineNum":"   32","line":"pub struct RecoveryId(i32);"},
{"lineNum":"   33","line":""},
{"lineNum":"   34","line":"/// An ECDSA signature with a recovery ID for pubkey recovery"},
{"lineNum":"   35","line":"#[derive(Copy, Clone, PartialEq, Eq, Debug)]","class":"linePartCov","hits":"2","order":"3821","possible_hits":"6",},
{"lineNum":"   36","line":"pub struct RecoverableSignature(ffi::RecoverableSignature);","class":"linePartCov","hits":"1","order":"3822","possible_hits":"3",},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"impl RecoveryId {"},
{"lineNum":"   39","line":"#[inline]"},
{"lineNum":"   40","line":"/// Allows library users to create valid recovery IDs from i32."},
{"lineNum":"   41","line":"pub fn from_i32(id: i32) -> Result<RecoveryId, Error> {","class":"lineCov","hits":"2","order":"2629","possible_hits":"2",},
{"lineNum":"   42","line":"    match id {","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   43","line":"        0 | 1 | 2 | 3 => Ok(RecoveryId(id)),","class":"lineCov","hits":"4","order":"2630","possible_hits":"4",},
{"lineNum":"   44","line":"        _ => Err(Error::InvalidRecoveryId)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   45","line":"    }"},
{"lineNum":"   46","line":"}","class":"linePartCov","hits":"2","order":"2631","possible_hits":"4",},
{"lineNum":"   47","line":""},
{"lineNum":"   48","line":"#[inline]"},
{"lineNum":"   49","line":"/// Allows library users to convert recovery IDs to i32."},
{"lineNum":"   50","line":"pub fn to_i32(self) -> i32 {","class":"lineCov","hits":"1","order":"2986","possible_hits":"1",},
{"lineNum":"   51","line":"    self.0"},
{"lineNum":"   52","line":"}","class":"linePartCov","hits":"1","order":"2987","possible_hits":"2",},
{"lineNum":"   53","line":"}"},
{"lineNum":"   54","line":""},
{"lineNum":"   55","line":"impl RecoverableSignature {"},
{"lineNum":"   56","line":"    #[inline]"},
{"lineNum":"   57","line":"    /// Converts a compact-encoded byte slice to a signature. This"},
{"lineNum":"   58","line":"    /// representation is nonstandard and defined by the libsecp256k1"},
{"lineNum":"   59","line":"    /// library."},
{"lineNum":"   60","line":"    pub fn from_compact(data: &[u8], recid: RecoveryId) -> Result<RecoverableSignature, Error> {","class":"lineCov","hits":"2","order":"2633","possible_hits":"2",},
{"lineNum":"   61","line":"        if data.is_empty() {return Err(Error::InvalidSignature);}","class":"linePartCov","hits":"2","order":"2634","possible_hits":"4",},
{"lineNum":"   62","line":""},
{"lineNum":"   63","line":"        let mut ret = ffi::RecoverableSignature::new();","class":"lineCov","hits":"2","order":"2635","possible_hits":"2",},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"        unsafe {"},
{"lineNum":"   66","line":"            if data.len() != 64 {","class":"linePartCov","hits":"4","order":"2637","possible_hits":"6",},
{"lineNum":"   67","line":"                Err(Error::InvalidSignature)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   68","line":"            } else if ffi::secp256k1_ecdsa_recoverable_signature_parse_compact(","class":"linePartCov","hits":"2","order":"2644","possible_hits":"4",},
{"lineNum":"   69","line":"                super_ffi::secp256k1_context_no_precomp,","class":"lineCov","hits":"2","order":"2638","possible_hits":"2",},
{"lineNum":"   70","line":"                &mut ret,"},
{"lineNum":"   71","line":"                data.as_c_ptr(),","class":"lineCov","hits":"2","order":"2639","possible_hits":"2",},
{"lineNum":"   72","line":"                recid.0,"},
{"lineNum":"   73","line":"            ) == 1"},
{"lineNum":"   74","line":"            {"},
{"lineNum":"   75","line":"                Ok(RecoverableSignature(ret))","class":"lineCov","hits":"2","order":"2695","possible_hits":"2",},
{"lineNum":"   76","line":"            } else {"},
{"lineNum":"   77","line":"                Err(Error::InvalidSignature)","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"   78","line":"            }"},
{"lineNum":"   79","line":"        }"},
{"lineNum":"   80","line":"    }","class":"linePartCov","hits":"4","order":"2696","possible_hits":"6",},
{"lineNum":"   81","line":""},
{"lineNum":"   82","line":"    /// Obtains a raw pointer suitable for use with FFI functions"},
{"lineNum":"   83","line":"    #[inline]"},
{"lineNum":"   84","line":"    pub fn as_ptr(&self) -> *const ffi::RecoverableSignature {","class":"lineCov","hits":"1","order":"2938","possible_hits":"1",},
{"lineNum":"   85","line":"        &self.0 as *const _"},
{"lineNum":"   86","line":"    }","class":"linePartCov","hits":"1","order":"2939","possible_hits":"2",},
{"lineNum":"   87","line":""},
{"lineNum":"   88","line":"    /// Obtains a raw mutable pointer suitable for use with FFI functions"},
{"lineNum":"   89","line":"    #[inline]"},
{"lineNum":"   90","line":"    pub fn as_mut_ptr(&mut self) -> *mut ffi::RecoverableSignature {"},
{"lineNum":"   91","line":"        &mut self.0 as *mut _"},
{"lineNum":"   92","line":"    }"},
{"lineNum":"   93","line":""},
{"lineNum":"   94","line":"    #[inline]"},
{"lineNum":"   95","line":"    /// Serializes the recoverable signature in compact format"},
{"lineNum":"   96","line":"    pub fn serialize_compact(&self) -> (RecoveryId, [u8; 64]) {","class":"lineCov","hits":"1","order":"2926","possible_hits":"1",},
{"lineNum":"   97","line":"        let mut ret = [0u8; 64];","class":"lineCov","hits":"1","order":"2927","possible_hits":"1",},
{"lineNum":"   98","line":"        let mut recid = 0i32;","class":"lineCov","hits":"1","order":"2928","possible_hits":"1",},
{"lineNum":"   99","line":"        unsafe {"},
{"lineNum":"  100","line":"            let err = ffi::secp256k1_ecdsa_recoverable_signature_serialize_compact(","class":"lineCov","hits":"1","order":"2941","possible_hits":"1",},
{"lineNum":"  101","line":"                super_ffi::secp256k1_context_no_precomp,","class":"lineCov","hits":"1","order":"2929","possible_hits":"1",},
{"lineNum":"  102","line":"                ret.as_mut_c_ptr(),","class":"lineCov","hits":"1","order":"2930","possible_hits":"1",},
{"lineNum":"  103","line":"                &mut recid,"},
{"lineNum":"  104","line":"                self.as_c_ptr(),","class":"lineCov","hits":"1","order":"2935","possible_hits":"1",},
{"lineNum":"  105","line":"            );"},
{"lineNum":"  106","line":"            assert!(err == 1);","class":"lineCov","hits":"1","order":"2962","possible_hits":"1",},
{"lineNum":"  107","line":"        }"},
{"lineNum":"  108","line":"        (RecoveryId(recid), ret)","class":"lineCov","hits":"1","order":"2963","possible_hits":"1",},
{"lineNum":"  109","line":"    }","class":"lineCov","hits":"1","order":"2964","possible_hits":"1",},
{"lineNum":"  110","line":""},
{"lineNum":"  111","line":"    /// Converts a recoverable signature to a non-recoverable one (this is needed"},
{"lineNum":"  112","line":"    /// for verification"},
{"lineNum":"  113","line":"    #[inline]"},
{"lineNum":"  114","line":"    pub fn to_standard(&self) -> Signature {","class":"lineCov","hits":"1","order":"5418","possible_hits":"1",},
{"lineNum":"  115","line":"        let mut ret = super_ffi::Signature::new();","class":"lineCov","hits":"1","order":"5419","possible_hits":"1",},
{"lineNum":"  116","line":"        unsafe {"},
{"lineNum":"  117","line":"            let err = ffi::secp256k1_ecdsa_recoverable_signature_convert(","class":"lineCov","hits":"1","order":"5423","possible_hits":"1",},
{"lineNum":"  118","line":"                super_ffi::secp256k1_context_no_precomp,","class":"lineCov","hits":"1","order":"5421","possible_hits":"1",},
{"lineNum":"  119","line":"                &mut ret,"},
{"lineNum":"  120","line":"                self.as_c_ptr(),","class":"lineCov","hits":"1","order":"5422","possible_hits":"1",},
{"lineNum":"  121","line":"            );"},
{"lineNum":"  122","line":"            assert!(err == 1);","class":"lineCov","hits":"1","order":"5435","possible_hits":"1",},
{"lineNum":"  123","line":"        }"},
{"lineNum":"  124","line":"        Signature(ret)","class":"lineCov","hits":"1","order":"5436","possible_hits":"1",},
{"lineNum":"  125","line":"    }","class":"lineCov","hits":"1","order":"5437","possible_hits":"1",},
{"lineNum":"  126","line":"}"},
{"lineNum":"  127","line":""},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"impl CPtr for RecoverableSignature {"},
{"lineNum":"  130","line":"    type Target = ffi::RecoverableSignature;"},
{"lineNum":"  131","line":"    fn as_c_ptr(&self) -> *const Self::Target {","class":"lineCov","hits":"1","order":"2936","possible_hits":"1",},
{"lineNum":"  132","line":"        self.as_ptr()","class":"lineCov","hits":"1","order":"2937","possible_hits":"1",},
{"lineNum":"  133","line":"    }","class":"linePartCov","hits":"1","order":"2940","possible_hits":"2",},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"    fn as_mut_c_ptr(&mut self) -> *mut Self::Target {"},
{"lineNum":"  136","line":"        self.as_mut_ptr()"},
{"lineNum":"  137","line":"    }"},
{"lineNum":"  138","line":"}"},
{"lineNum":"  139","line":""},
{"lineNum":"  140","line":"/// Creates a new recoverable signature from a FFI one"},
{"lineNum":"  141","line":"impl From<ffi::RecoverableSignature> for RecoverableSignature {"},
{"lineNum":"  142","line":"    #[inline]"},
{"lineNum":"  143","line":"    fn from(sig: ffi::RecoverableSignature) -> RecoverableSignature {"},
{"lineNum":"  144","line":"        RecoverableSignature(sig)"},
{"lineNum":"  145","line":"    }"},
{"lineNum":"  146","line":"}"},
{"lineNum":"  147","line":""},
{"lineNum":"  148","line":"impl<C: Signing> Secp256k1<C> {"},
{"lineNum":"  149","line":"    /// Constructs a signature for `msg` using the secret key `sk` and RFC6979 nonce"},
{"lineNum":"  150","line":"    /// Requires a signing-capable context."},
{"lineNum":"  151","line":"    pub fn sign_recoverable(&self, msg: &Message, sk: &key::SecretKey)"},
{"lineNum":"  152","line":"                            -> RecoverableSignature {"},
{"lineNum":"  153","line":""},
{"lineNum":"  154","line":"        let mut ret = ffi::RecoverableSignature::new();"},
{"lineNum":"  155","line":"        unsafe {"},
{"lineNum":"  156","line":"            // We can assume the return value because it\'s not possible to construct"},
{"lineNum":"  157","line":"            // an invalid signature from a valid `Message` and `SecretKey`"},
{"lineNum":"  158","line":"            assert_eq!("},
{"lineNum":"  159","line":"                ffi::secp256k1_ecdsa_sign_recoverable("},
{"lineNum":"  160","line":"                    self.ctx,"},
{"lineNum":"  161","line":"                    &mut ret,"},
{"lineNum":"  162","line":"                    msg.as_c_ptr(),"},
{"lineNum":"  163","line":"                    sk.as_c_ptr(),"},
{"lineNum":"  164","line":"                    super_ffi::secp256k1_nonce_function_rfc6979,"},
{"lineNum":"  165","line":"                    ptr::null()"},
{"lineNum":"  166","line":"                ),"},
{"lineNum":"  167","line":"                1"},
{"lineNum":"  168","line":"            );"},
{"lineNum":"  169","line":"        }"},
{"lineNum":"  170","line":""},
{"lineNum":"  171","line":"        RecoverableSignature::from(ret)"},
{"lineNum":"  172","line":"    }"},
{"lineNum":"  173","line":"}"},
{"lineNum":"  174","line":""},
{"lineNum":"  175","line":"impl<C: Verification> Secp256k1<C> {"},
{"lineNum":"  176","line":"    /// Determines the public key for which `sig` is a valid signature for"},
{"lineNum":"  177","line":"    /// `msg`. Requires a verify-capable context."},
{"lineNum":"  178","line":"    pub fn recover(&self, msg: &Message, sig: &RecoverableSignature)","class":"lineCov","hits":"1","order":"4910","possible_hits":"1",},
{"lineNum":"  179","line":"                   -> Result<key::PublicKey, Error> {"},
{"lineNum":"  180","line":""},
{"lineNum":"  181","line":"        let mut pk = super_ffi::PublicKey::new();","class":"lineCov","hits":"1","order":"4911","possible_hits":"1",},
{"lineNum":"  182","line":""},
{"lineNum":"  183","line":"        unsafe {"},
{"lineNum":"  184","line":"            if ffi::secp256k1_ecdsa_recover(self.ctx, &mut pk,","class":"lineCov","hits":"2","order":"4913","possible_hits":"2",},
{"lineNum":"  185","line":"                                            sig.as_c_ptr(), msg.as_c_ptr()) != 1 {","class":"lineCov","hits":"1","order":"4914","possible_hits":"1",},
{"lineNum":"  186","line":"                return Err(Error::InvalidSignature);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  187","line":"            }"},
{"lineNum":"  188","line":"        };"},
{"lineNum":"  189","line":"        Ok(key::PublicKey::from(pk))","class":"lineCov","hits":"2","order":"5328","possible_hits":"2",},
{"lineNum":"  190","line":"    }","class":"linePartCov","hits":"2","order":"5332","possible_hits":"3",},
{"lineNum":"  191","line":"}"},
{"lineNum":"  192","line":""},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"#[cfg(test)]"},
{"lineNum":"  195","line":"mod tests {"},
{"lineNum":"  196","line":"    use rand::{RngCore, thread_rng};"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"    use key::SecretKey;"},
{"lineNum":"  199","line":"    use super::{RecoveryId, RecoverableSignature};"},
{"lineNum":"  200","line":"    use super::super::{Secp256k1, Message};"},
{"lineNum":"  201","line":"    use super::super::Error::{IncorrectSignature, InvalidSignature};"},
{"lineNum":"  202","line":""},
{"lineNum":"  203","line":"    #[test]"},
{"lineNum":"  204","line":"    fn capabilities() {"},
{"lineNum":"  205","line":"        let sign = Secp256k1::signing_only();"},
{"lineNum":"  206","line":"        let vrfy = Secp256k1::verification_only();"},
{"lineNum":"  207","line":"        let full = Secp256k1::new();"},
{"lineNum":"  208","line":""},
{"lineNum":"  209","line":"        let mut msg = [0u8; 32];"},
{"lineNum":"  210","line":"        thread_rng().fill_bytes(&mut msg);"},
{"lineNum":"  211","line":"        let msg = Message::from_slice(&msg).unwrap();"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"        // Try key generation"},
{"lineNum":"  214","line":"        let (sk, pk) = full.generate_keypair(&mut thread_rng());"},
{"lineNum":"  215","line":""},
{"lineNum":"  216","line":"        // Try signing"},
{"lineNum":"  217","line":"        assert_eq!(sign.sign_recoverable(&msg, &sk), full.sign_recoverable(&msg, &sk));"},
{"lineNum":"  218","line":"        let sigr = full.sign_recoverable(&msg, &sk);"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"        // Try pk recovery"},
{"lineNum":"  221","line":"        assert!(vrfy.recover(&msg, &sigr).is_ok());"},
{"lineNum":"  222","line":"        assert!(full.recover(&msg, &sigr).is_ok());"},
{"lineNum":"  223","line":""},
{"lineNum":"  224","line":"        assert_eq!(vrfy.recover(&msg, &sigr),"},
{"lineNum":"  225","line":"                   full.recover(&msg, &sigr));"},
{"lineNum":"  226","line":"        assert_eq!(full.recover(&msg, &sigr), Ok(pk));"},
{"lineNum":"  227","line":"    }"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"    #[test]"},
{"lineNum":"  230","line":"    fn recid_sanity_check() {"},
{"lineNum":"  231","line":"        let one = RecoveryId(1);"},
{"lineNum":"  232","line":"        assert_eq!(one, one.clone());"},
{"lineNum":"  233","line":"    }"},
{"lineNum":"  234","line":""},
{"lineNum":"  235","line":"    #[test]"},
{"lineNum":"  236","line":"    fn sign() {"},
{"lineNum":"  237","line":"        let mut s = Secp256k1::new();"},
{"lineNum":"  238","line":"        s.randomize(&mut thread_rng());"},
{"lineNum":"  239","line":"        let one = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,"},
{"lineNum":"  240","line":"                   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1];"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"        let sk = SecretKey::from_slice(&one).unwrap();"},
{"lineNum":"  243","line":"        let msg = Message::from_slice(&one).unwrap();"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"        let sig = s.sign_recoverable(&msg, &sk);"},
{"lineNum":"  246","line":"        assert_eq!(Ok(sig), RecoverableSignature::from_compact(&["},
{"lineNum":"  247","line":"            0x66, 0x73, 0xff, 0xad, 0x21, 0x47, 0x74, 0x1f,"},
{"lineNum":"  248","line":"            0x04, 0x77, 0x2b, 0x6f, 0x92, 0x1f, 0x0b, 0xa6,"},
{"lineNum":"  249","line":"            0xaf, 0x0c, 0x1e, 0x77, 0xfc, 0x43, 0x9e, 0x65,"},
{"lineNum":"  250","line":"            0xc3, 0x6d, 0xed, 0xf4, 0x09, 0x2e, 0x88, 0x98,"},
{"lineNum":"  251","line":"            0x4c, 0x1a, 0x97, 0x16, 0x52, 0xe0, 0xad, 0xa8,"},
{"lineNum":"  252","line":"            0x80, 0x12, 0x0e, 0xf8, 0x02, 0x5e, 0x70, 0x9f,"},
{"lineNum":"  253","line":"            0xff, 0x20, 0x80, 0xc4, 0xa3, 0x9a, 0xae, 0x06,"},
{"lineNum":"  254","line":"            0x8d, 0x12, 0xee, 0xd0, 0x09, 0xb6, 0x8c, 0x89],"},
{"lineNum":"  255","line":"            RecoveryId(1)))"},
{"lineNum":"  256","line":"    }"},
{"lineNum":"  257","line":""},
{"lineNum":"  258","line":"    #[test]"},
{"lineNum":"  259","line":"    fn sign_and_verify_fail() {"},
{"lineNum":"  260","line":"        let mut s = Secp256k1::new();"},
{"lineNum":"  261","line":"        s.randomize(&mut thread_rng());"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"        let mut msg = [0u8; 32];"},
{"lineNum":"  264","line":"        thread_rng().fill_bytes(&mut msg);"},
{"lineNum":"  265","line":"        let msg = Message::from_slice(&msg).unwrap();"},
{"lineNum":"  266","line":""},
{"lineNum":"  267","line":"        let (sk, pk) = s.generate_keypair(&mut thread_rng());"},
{"lineNum":"  268","line":""},
{"lineNum":"  269","line":"        let sigr = s.sign_recoverable(&msg, &sk);"},
{"lineNum":"  270","line":"        let sig = sigr.to_standard();"},
{"lineNum":"  271","line":""},
{"lineNum":"  272","line":"        let mut msg = [0u8; 32];"},
{"lineNum":"  273","line":"        thread_rng().fill_bytes(&mut msg);"},
{"lineNum":"  274","line":"        let msg = Message::from_slice(&msg).unwrap();"},
{"lineNum":"  275","line":"        assert_eq!(s.verify(&msg, &sig, &pk), Err(IncorrectSignature));"},
{"lineNum":"  276","line":""},
{"lineNum":"  277","line":"        let recovered_key = s.recover(&msg, &sigr).unwrap();"},
{"lineNum":"  278","line":"        assert!(recovered_key != pk);"},
{"lineNum":"  279","line":"    }"},
{"lineNum":"  280","line":""},
{"lineNum":"  281","line":"    #[test]"},
{"lineNum":"  282","line":"    fn sign_with_recovery() {"},
{"lineNum":"  283","line":"        let mut s = Secp256k1::new();"},
{"lineNum":"  284","line":"        s.randomize(&mut thread_rng());"},
{"lineNum":"  285","line":""},
{"lineNum":"  286","line":"        let mut msg = [0u8; 32];"},
{"lineNum":"  287","line":"        thread_rng().fill_bytes(&mut msg);"},
{"lineNum":"  288","line":"        let msg = Message::from_slice(&msg).unwrap();"},
{"lineNum":"  289","line":""},
{"lineNum":"  290","line":"        let (sk, pk) = s.generate_keypair(&mut thread_rng());"},
{"lineNum":"  291","line":""},
{"lineNum":"  292","line":"        let sig = s.sign_recoverable(&msg, &sk);"},
{"lineNum":"  293","line":""},
{"lineNum":"  294","line":"        assert_eq!(s.recover(&msg, &sig), Ok(pk));"},
{"lineNum":"  295","line":"    }"},
{"lineNum":"  296","line":""},
{"lineNum":"  297","line":"    #[test]"},
{"lineNum":"  298","line":"    fn bad_recovery() {"},
{"lineNum":"  299","line":"        let mut s = Secp256k1::new();"},
{"lineNum":"  300","line":"        s.randomize(&mut thread_rng());"},
{"lineNum":"  301","line":""},
{"lineNum":"  302","line":"        let msg = Message::from_slice(&[0x55; 32]).unwrap();"},
{"lineNum":"  303","line":""},
{"lineNum":"  304","line":"        // Zero is not a valid sig"},
{"lineNum":"  305","line":"        let sig = RecoverableSignature::from_compact(&[0; 64], RecoveryId(0)).unwrap();"},
{"lineNum":"  306","line":"        assert_eq!(s.recover(&msg, &sig), Err(InvalidSignature));"},
{"lineNum":"  307","line":"        // ...but 111..111 is"},
{"lineNum":"  308","line":"        let sig = RecoverableSignature::from_compact(&[1; 64], RecoveryId(0)).unwrap();"},
{"lineNum":"  309","line":"        assert!(s.recover(&msg, &sig).is_ok());"},
{"lineNum":"  310","line":"    }"},
{"lineNum":"  311","line":""},
{"lineNum":"  312","line":"    #[test]"},
{"lineNum":"  313","line":"    fn test_debug_output() {"},
{"lineNum":"  314","line":"        let sig = RecoverableSignature::from_compact(&["},
{"lineNum":"  315","line":"            0x66, 0x73, 0xff, 0xad, 0x21, 0x47, 0x74, 0x1f,"},
{"lineNum":"  316","line":"            0x04, 0x77, 0x2b, 0x6f, 0x92, 0x1f, 0x0b, 0xa6,"},
{"lineNum":"  317","line":"            0xaf, 0x0c, 0x1e, 0x77, 0xfc, 0x43, 0x9e, 0x65,"},
{"lineNum":"  318","line":"            0xc3, 0x6d, 0xed, 0xf4, 0x09, 0x2e, 0x88, 0x98,"},
{"lineNum":"  319","line":"            0x4c, 0x1a, 0x97, 0x16, 0x52, 0xe0, 0xad, 0xa8,"},
{"lineNum":"  320","line":"            0x80, 0x12, 0x0e, 0xf8, 0x02, 0x5e, 0x70, 0x9f,"},
{"lineNum":"  321","line":"            0xff, 0x20, 0x80, 0xc4, 0xa3, 0x9a, 0xae, 0x06,"},
{"lineNum":"  322","line":"            0x8d, 0x12, 0xee, 0xd0, 0x09, 0xb6, 0x8c, 0x89],"},
{"lineNum":"  323","line":"            RecoveryId(1)).unwrap();"},
{"lineNum":"  324","line":"        assert_eq!(&format!(\"{:?}\", sig), \"RecoverableSignature(98882e09f4ed6dc3659e43fc771e0cafa60b1f926f2b77041f744721adff7366898cb609d0ee128d06ae9aa3c48020ff9f705e02f80e1280a8ade05216971a4c01)\");"},
{"lineNum":"  325","line":"    }"},
{"lineNum":"  326","line":""},
{"lineNum":"  327","line":"    #[test]"},
{"lineNum":"  328","line":"    fn test_recov_sig_serialize_compact() {"},
{"lineNum":"  329","line":"        let recid_in = RecoveryId(1);"},
{"lineNum":"  330","line":"        let bytes_in = &["},
{"lineNum":"  331","line":"            0x66, 0x73, 0xff, 0xad, 0x21, 0x47, 0x74, 0x1f,"},
{"lineNum":"  332","line":"            0x04, 0x77, 0x2b, 0x6f, 0x92, 0x1f, 0x0b, 0xa6,"},
{"lineNum":"  333","line":"            0xaf, 0x0c, 0x1e, 0x77, 0xfc, 0x43, 0x9e, 0x65,"},
{"lineNum":"  334","line":"            0xc3, 0x6d, 0xed, 0xf4, 0x09, 0x2e, 0x88, 0x98,"},
{"lineNum":"  335","line":"            0x4c, 0x1a, 0x97, 0x16, 0x52, 0xe0, 0xad, 0xa8,"},
{"lineNum":"  336","line":"            0x80, 0x12, 0x0e, 0xf8, 0x02, 0x5e, 0x70, 0x9f,"},
{"lineNum":"  337","line":"            0xff, 0x20, 0x80, 0xc4, 0xa3, 0x9a, 0xae, 0x06,"},
{"lineNum":"  338","line":"            0x8d, 0x12, 0xee, 0xd0, 0x09, 0xb6, 0x8c, 0x89];"},
{"lineNum":"  339","line":"        let sig = RecoverableSignature::from_compact("},
{"lineNum":"  340","line":"            bytes_in,"},
{"lineNum":"  341","line":"            recid_in,"},
{"lineNum":"  342","line":"        ).unwrap();"},
{"lineNum":"  343","line":"        let (recid_out, bytes_out) = sig.serialize_compact();"},
{"lineNum":"  344","line":"        assert_eq!(recid_in, recid_out);"},
{"lineNum":"  345","line":"        assert_eq!(&bytes_in[..], &bytes_out[..]);"},
{"lineNum":"  346","line":"    }"},
{"lineNum":"  347","line":""},
{"lineNum":"  348","line":"    #[test]"},
{"lineNum":"  349","line":"    fn test_recov_id_conversion_between_i32() {"},
{"lineNum":"  350","line":"        assert!(RecoveryId::from_i32(-1).is_err());"},
{"lineNum":"  351","line":"        assert!(RecoveryId::from_i32(0).is_ok());"},
{"lineNum":"  352","line":"        assert!(RecoveryId::from_i32(1).is_ok());"},
{"lineNum":"  353","line":"        assert!(RecoveryId::from_i32(2).is_ok());"},
{"lineNum":"  354","line":"        assert!(RecoveryId::from_i32(3).is_ok());"},
{"lineNum":"  355","line":"        assert!(RecoveryId::from_i32(4).is_err());"},
{"lineNum":"  356","line":"        let id0 = RecoveryId::from_i32(0).unwrap();"},
{"lineNum":"  357","line":"        assert_eq!(id0.to_i32(), 0);"},
{"lineNum":"  358","line":"        let id1 = RecoveryId(1);"},
{"lineNum":"  359","line":"        assert_eq!(id1.to_i32(), 1);"},
{"lineNum":"  360","line":"    }"},
{"lineNum":"  361","line":"}"},
{"lineNum":"  362","line":""},
{"lineNum":"  363","line":""},
{"lineNum":"  364","line":"#[cfg(all(test, feature = \"unstable\"))]"},
{"lineNum":"  365","line":"mod benches {"},
{"lineNum":"  366","line":"    #[bench]"},
{"lineNum":"  367","line":"    pub fn bench_recover(bh: &mut Bencher) {"},
{"lineNum":"  368","line":"        let s = Secp256k1::new();"},
{"lineNum":"  369","line":"        let mut msg = [0u8; 32];"},
{"lineNum":"  370","line":"        thread_rng().fill_bytes(&mut msg);"},
{"lineNum":"  371","line":"        let msg = Message::from_slice(&msg).unwrap();"},
{"lineNum":"  372","line":"        let (sk, _) = s.generate_keypair(&mut thread_rng());"},
{"lineNum":"  373","line":"        let sig = s.sign_recoverable(&msg, &sk);"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"        bh.iter(|| {"},
{"lineNum":"  376","line":"            let res = s.recover(&msg, &sig).unwrap();"},
{"lineNum":"  377","line":"            black_box(res);"},
{"lineNum":"  378","line":"        });"},
{"lineNum":"  379","line":"    }"},
{"lineNum":"  380","line":"}"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "ser_de-82e03ad9d566398b", "date" : "2020-05-23 13:12:49", "instrumented" : 50, "covered" : 45,};
var merged_data = [];
