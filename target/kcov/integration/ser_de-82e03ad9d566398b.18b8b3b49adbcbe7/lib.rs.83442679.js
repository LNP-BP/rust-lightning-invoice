var data = {lines:[
{"lineNum":"    1","line":"// Bitcoin Hashes Library"},
{"lineNum":"    2","line":"// Written in 2018 by"},
{"lineNum":"    3","line":"//   Andrew Poelstra <apoelstra@wpsoftware.net>"},
{"lineNum":"    4","line":"//"},
{"lineNum":"    5","line":"// To the extent possible under law, the author(s) have dedicated all"},
{"lineNum":"    6","line":"// copyright and related and neighboring rights to this software to"},
{"lineNum":"    7","line":"// the public domain worldwide. This software is distributed without"},
{"lineNum":"    8","line":"// any warranty."},
{"lineNum":"    9","line":"//"},
{"lineNum":"   10","line":"// You should have received a copy of the CC0 Public Domain Dedication"},
{"lineNum":"   11","line":"// along with this software."},
{"lineNum":"   12","line":"// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>."},
{"lineNum":"   13","line":"//"},
{"lineNum":"   14","line":""},
{"lineNum":"   15","line":"//! # Rust Hashes Library"},
{"lineNum":"   16","line":"//!"},
{"lineNum":"   17","line":"//! This is a simple, no-dependency library which implements the hash functions"},
{"lineNum":"   18","line":"//! needed by Bitcoin. These are SHA256, SHA256d, and RIPEMD160. As an ancillary"},
{"lineNum":"   19","line":"//! thing, it exposes hexadecimal serialization and deserialization, since these"},
{"lineNum":"   20","line":"//! are needed to display hashes anway."},
{"lineNum":"   21","line":"//!"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"// Coding conventions"},
{"lineNum":"   24","line":"#![deny(non_upper_case_globals)]"},
{"lineNum":"   25","line":"#![deny(non_camel_case_types)]"},
{"lineNum":"   26","line":"#![deny(non_snake_case)]"},
{"lineNum":"   27","line":"#![deny(unused_mut)]"},
{"lineNum":"   28","line":"#![deny(missing_docs)]"},
{"lineNum":"   29","line":""},
{"lineNum":"   30","line":"// In general, rust is absolutely horrid at supporting users doing things like,"},
{"lineNum":"   31","line":"// for example, compiling Rust code for real environments. Disable useless lints"},
{"lineNum":"   32","line":"// that don\'t do anything but annoy us and cant actually ever be resolved."},
{"lineNum":"   33","line":"#![allow(bare_trait_objects)]"},
{"lineNum":"   34","line":"#![allow(ellipsis_inclusive_range_patterns)]"},
{"lineNum":"   35","line":""},
{"lineNum":"   36","line":"#![cfg_attr(all(not(test), not(feature = \"std\")), no_std)]"},
{"lineNum":"   37","line":"#![cfg_attr(all(test, feature = \"unstable\"), feature(test))]"},
{"lineNum":"   38","line":"#[cfg(all(test, feature = \"unstable\"))] extern crate test;"},
{"lineNum":"   39","line":""},
{"lineNum":"   40","line":"#[cfg(any(test, feature=\"std\"))] pub extern crate core;"},
{"lineNum":"   41","line":"#[cfg(feature=\"serde\")] pub extern crate serde;"},
{"lineNum":"   42","line":"#[cfg(all(test,feature=\"serde\"))] extern crate serde_test;"},
{"lineNum":"   43","line":""},
{"lineNum":"   44","line":"#[macro_use] mod util;"},
{"lineNum":"   45","line":"#[macro_use] mod serde_macros;"},
{"lineNum":"   46","line":"#[cfg(any(test, feature = \"std\"))] mod std_impls;"},
{"lineNum":"   47","line":"pub mod error;"},
{"lineNum":"   48","line":"pub mod hex;"},
{"lineNum":"   49","line":"pub mod hash160;"},
{"lineNum":"   50","line":"pub mod hmac;"},
{"lineNum":"   51","line":"pub mod ripemd160;"},
{"lineNum":"   52","line":"pub mod sha1;"},
{"lineNum":"   53","line":"pub mod sha256;"},
{"lineNum":"   54","line":"pub mod sha256d;"},
{"lineNum":"   55","line":"pub mod sha256t;"},
{"lineNum":"   56","line":"pub mod siphash24;"},
{"lineNum":"   57","line":"pub mod sha512;"},
{"lineNum":"   58","line":"pub mod cmp;"},
{"lineNum":"   59","line":""},
{"lineNum":"   60","line":"use core::{borrow, fmt, hash, ops};"},
{"lineNum":"   61","line":""},
{"lineNum":"   62","line":"pub use hmac::{Hmac, HmacEngine};"},
{"lineNum":"   63","line":"pub use error::Error;"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"/// A hashing engine which bytes can be serialized into. It is expected"},
{"lineNum":"   66","line":"/// to implement the `io::Write` trait, but to never return errors under"},
{"lineNum":"   67","line":"/// any conditions."},
{"lineNum":"   68","line":"pub trait HashEngine: Clone + Default {"},
{"lineNum":"   69","line":"    /// Byte array representing the internal state of the hash engine"},
{"lineNum":"   70","line":"    type MidState;"},
{"lineNum":"   71","line":""},
{"lineNum":"   72","line":"    /// Outputs the midstate of the hash engine. This function should not be"},
{"lineNum":"   73","line":"    /// used directly unless you really know what you\'re doing."},
{"lineNum":"   74","line":"    fn midstate(&self) -> Self::MidState;"},
{"lineNum":"   75","line":""},
{"lineNum":"   76","line":"    /// Length of the hash\'s internal block size, in bytes"},
{"lineNum":"   77","line":"    const BLOCK_SIZE: usize;"},
{"lineNum":"   78","line":""},
{"lineNum":"   79","line":"    /// Add data to the hash engine"},
{"lineNum":"   80","line":"    fn input(&mut self, data: &[u8]);"},
{"lineNum":"   81","line":"}"},
{"lineNum":"   82","line":""},
{"lineNum":"   83","line":"/// Trait which applies to hashes of all types"},
{"lineNum":"   84","line":"pub trait Hash: Copy + Clone + PartialEq + Eq + Default + PartialOrd + Ord +"},
{"lineNum":"   85","line":"    hash::Hash + fmt::Debug + fmt::Display + fmt::LowerHex +"},
{"lineNum":"   86","line":"    ops::Index<ops::RangeFull, Output = [u8]> +"},
{"lineNum":"   87","line":"    ops::Index<ops::RangeFrom<usize>, Output = [u8]> +"},
{"lineNum":"   88","line":"    ops::Index<ops::RangeTo<usize>, Output = [u8]> +"},
{"lineNum":"   89","line":"    ops::Index<ops::Range<usize>, Output = [u8]> +"},
{"lineNum":"   90","line":"    ops::Index<usize, Output = u8> +"},
{"lineNum":"   91","line":"    borrow::Borrow<[u8]>"},
{"lineNum":"   92","line":"{"},
{"lineNum":"   93","line":"    /// A hashing engine which bytes can be serialized into. It is expected"},
{"lineNum":"   94","line":"    /// to implement the `io::Write` trait, and to never return errors under"},
{"lineNum":"   95","line":"    /// any conditions."},
{"lineNum":"   96","line":"    type Engine: HashEngine;"},
{"lineNum":"   97","line":""},
{"lineNum":"   98","line":"    /// The byte array that represents the hash internally"},
{"lineNum":"   99","line":"    type Inner: hex::FromHex;"},
{"lineNum":"  100","line":""},
{"lineNum":"  101","line":"    /// Construct a new engine"},
{"lineNum":"  102","line":"    fn engine() -> Self::Engine {","class":"lineCov","hits":"1","order":"2333","possible_hits":"1",},
{"lineNum":"  103","line":"        Self::Engine::default()","class":"lineCov","hits":"1","order":"2334","possible_hits":"1",},
{"lineNum":"  104","line":"    }","class":"linePartCov","hits":"1","order":"2340","possible_hits":"2",},
{"lineNum":"  105","line":""},
{"lineNum":"  106","line":"    /// Produce a hash from the current state of a given engine"},
{"lineNum":"  107","line":"    fn from_engine(e: Self::Engine) -> Self;"},
{"lineNum":"  108","line":""},
{"lineNum":"  109","line":"    /// Length of the hash, in bytes"},
{"lineNum":"  110","line":"    const LEN: usize;"},
{"lineNum":"  111","line":""},
{"lineNum":"  112","line":"    /// Copies a byte slice into a hash object"},
{"lineNum":"  113","line":"    fn from_slice(sl: &[u8]) -> Result<Self, Error>;"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    /// Hashes some bytes"},
{"lineNum":"  116","line":"    fn hash(data: &[u8]) -> Self {","class":"linePartCov","hits":"1","order":"2331","possible_hits":"2",},
{"lineNum":"  117","line":"        let mut engine = Self::engine();","class":"lineCov","hits":"1","order":"2332","possible_hits":"1",},
{"lineNum":"  118","line":"        engine.input(data);","class":"lineCov","hits":"1","order":"2341","possible_hits":"1",},
{"lineNum":"  119","line":"        Self::from_engine(engine)","class":"lineCov","hits":"1","order":"2549","possible_hits":"1",},
{"lineNum":"  120","line":"    }","class":"lineCov","hits":"1","order":"2601","possible_hits":"1",},
{"lineNum":"  121","line":""},
{"lineNum":"  122","line":"    /// Flag indicating whether user-visible serializations of this hash"},
{"lineNum":"  123","line":"    /// should be backward. For some reason Satoshi decided this should be"},
{"lineNum":"  124","line":"    /// true for `Sha256dHash`, so here we are."},
{"lineNum":"  125","line":"    const DISPLAY_BACKWARD: bool = false;"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    /// Unwraps the hash and returns the underlying byte array"},
{"lineNum":"  128","line":"    fn into_inner(self) -> Self::Inner;"},
{"lineNum":"  129","line":""},
{"lineNum":"  130","line":"    /// Constructs a hash from the underlying byte array"},
{"lineNum":"  131","line":"    fn from_inner(inner: Self::Inner) -> Self;"},
{"lineNum":"  132","line":"}"},
{"lineNum":"  133","line":""},
{"lineNum":"  134","line":"/// Create a new newtype around a [Hash] type."},
{"lineNum":"  135","line":"#[macro_export]"},
{"lineNum":"  136","line":"macro_rules! hash_newtype {"},
{"lineNum":"  137","line":"    ($newtype:ident, $hash:ty, $len:expr, $docs:meta) => {"},
{"lineNum":"  138","line":"        hash_newtype!($newtype, $hash, $len, $docs, <$hash as $crate::Hash>::DISPLAY_BACKWARD);"},
{"lineNum":"  139","line":"    };"},
{"lineNum":"  140","line":"    ($newtype:ident, $hash:ty, $len:expr, $docs:meta, $reverse:expr) => {"},
{"lineNum":"  141","line":"        #[$docs]"},
{"lineNum":"  142","line":"        #[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]"},
{"lineNum":"  143","line":"        pub struct $newtype($hash);"},
{"lineNum":"  144","line":""},
{"lineNum":"  145","line":"        hex_fmt_impl!(Debug, $newtype);"},
{"lineNum":"  146","line":"        hex_fmt_impl!(Display, $newtype);"},
{"lineNum":"  147","line":"        hex_fmt_impl!(LowerHex, $newtype);"},
{"lineNum":"  148","line":"        index_impl!($newtype);"},
{"lineNum":"  149","line":"        serde_impl!($newtype, $len);"},
{"lineNum":"  150","line":"        borrow_slice_impl!($newtype);"},
{"lineNum":"  151","line":""},
{"lineNum":"  152","line":"        impl $newtype {"},
{"lineNum":"  153","line":"            /// Create this type from the inner hash type."},
{"lineNum":"  154","line":"            pub fn from_hash(inner: $hash) -> $newtype {"},
{"lineNum":"  155","line":"                $newtype(inner)"},
{"lineNum":"  156","line":"            }"},
{"lineNum":"  157","line":""},
{"lineNum":"  158","line":"            /// Convert this type into the inner hash type."},
{"lineNum":"  159","line":"            pub fn as_hash(&self) -> $hash {"},
{"lineNum":"  160","line":"                // Hashes implement Copy so don\'t need into_hash."},
{"lineNum":"  161","line":"                self.0"},
{"lineNum":"  162","line":"            }"},
{"lineNum":"  163","line":"        }"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"        impl ::std::convert::From<$hash> for $newtype {"},
{"lineNum":"  166","line":"            fn from(inner: $hash) -> $newtype {"},
{"lineNum":"  167","line":"                // Due to rust 1.22 we have to use this instead of simple `Self(inner)`"},
{"lineNum":"  168","line":"                Self { 0: inner }"},
{"lineNum":"  169","line":"            }"},
{"lineNum":"  170","line":"        }"},
{"lineNum":"  171","line":""},
{"lineNum":"  172","line":"        impl ::std::convert::From<$newtype> for $hash {"},
{"lineNum":"  173","line":"            fn from(hashtype: $newtype) -> $hash {"},
{"lineNum":"  174","line":"                hashtype.0"},
{"lineNum":"  175","line":"            }"},
{"lineNum":"  176","line":"        }"},
{"lineNum":"  177","line":""},
{"lineNum":"  178","line":"        impl $crate::Hash for $newtype {"},
{"lineNum":"  179","line":"            type Engine = <$hash as $crate::Hash>::Engine;"},
{"lineNum":"  180","line":"            type Inner = <$hash as $crate::Hash>::Inner;"},
{"lineNum":"  181","line":""},
{"lineNum":"  182","line":"            const LEN: usize = <$hash as $crate::Hash>::LEN;"},
{"lineNum":"  183","line":"            const DISPLAY_BACKWARD: bool = $reverse;"},
{"lineNum":"  184","line":""},
{"lineNum":"  185","line":"            fn from_engine(e: Self::Engine) -> Self {"},
{"lineNum":"  186","line":"                Self::from(<$hash as $crate::Hash>::from_engine(e))"},
{"lineNum":"  187","line":"            }"},
{"lineNum":"  188","line":""},
{"lineNum":"  189","line":"            #[inline]"},
{"lineNum":"  190","line":"            fn from_slice(sl: &[u8]) -> Result<$newtype, $crate::Error> {"},
{"lineNum":"  191","line":"                Ok($newtype(<$hash as $crate::Hash>::from_slice(sl)?))"},
{"lineNum":"  192","line":"            }"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"            #[inline]"},
{"lineNum":"  195","line":"            fn from_inner(inner: Self::Inner) -> Self {"},
{"lineNum":"  196","line":"                $newtype(<$hash as $crate::Hash>::from_inner(inner))"},
{"lineNum":"  197","line":"            }"},
{"lineNum":"  198","line":""},
{"lineNum":"  199","line":"            #[inline]"},
{"lineNum":"  200","line":"            fn into_inner(self) -> Self::Inner {"},
{"lineNum":"  201","line":"                self.0.into_inner()"},
{"lineNum":"  202","line":"            }"},
{"lineNum":"  203","line":"        }"},
{"lineNum":"  204","line":""},
{"lineNum":"  205","line":"        impl ::std::str::FromStr for $newtype {"},
{"lineNum":"  206","line":"            type Err = <$hash as ::std::str::FromStr>::Err;"},
{"lineNum":"  207","line":"            fn from_str(s: &str) -> ::std::result::Result<$newtype, Self::Err> {"},
{"lineNum":"  208","line":"                s.parse().map($newtype)"},
{"lineNum":"  209","line":"            }"},
{"lineNum":"  210","line":"        }"},
{"lineNum":"  211","line":"    };"},
{"lineNum":"  212","line":"}"},
{"lineNum":"  213","line":""},
{"lineNum":"  214","line":"#[cfg(test)]"},
{"lineNum":"  215","line":"mod test {"},
{"lineNum":"  216","line":"    use Hash;"},
{"lineNum":"  217","line":"    hash_newtype!(TestNewtype, ::sha256d::Hash, 32, doc=\"A test newtype\");"},
{"lineNum":"  218","line":"    hash_newtype!(TestNewtype2, ::sha256d::Hash, 32, doc=\"A test newtype\");"},
{"lineNum":"  219","line":""},
{"lineNum":"  220","line":"    #[test]"},
{"lineNum":"  221","line":"    fn convert_newtypes() {"},
{"lineNum":"  222","line":"        let h1 = TestNewtype::hash(&[]);"},
{"lineNum":"  223","line":"        let h2: TestNewtype2 = h1.as_hash().into();"},
{"lineNum":"  224","line":"        assert_eq!(&h1[..], &h2[..]);"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"        let h = ::sha256d::Hash::hash(&[]);"},
{"lineNum":"  227","line":"        let h2: TestNewtype = h.to_string().parse().unwrap();"},
{"lineNum":"  228","line":"        assert_eq!(h2.as_hash(), h);"},
{"lineNum":"  229","line":"    }"},
{"lineNum":"  230","line":"}"},
{"lineNum":"  231","line":""},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "ser_de-82e03ad9d566398b", "date" : "2020-05-23 13:12:49", "instrumented" : 8, "covered" : 8,};
var merged_data = [];
